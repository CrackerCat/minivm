
#include <stdio.h>
#include <stdlib.h>
#include "../luajit/dynasm/dasm_proto.h"
#include "../luajit/dynasm/dasm_x86.h"
#include <sys/mman.h>

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "vm.h"
#include "lib.h"

#define MAX_NESTING 100

struct vm_state_t;
typedef struct vm_state_t vm_state_t;

int vm_run(size_t nops, const vm_opcode_t *ops)
{
  dasm_State* d;
  |.arch x64
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist vm_actions
  dasm_setup(&d, vm_actions);
  dasm_growpc(&d, nops);
  |.define arg1, rdi
  |.define arg2, rsi
  |.define arg3, rdx
  |.define arg4, rcx
  |.define arg5, r8
  |.define arg6, r9
  |.macro prologue
    |push rdi
    |push rsi
    |push rdx
    |push rcx
    |push r8
    |push r9  
    |push locals
    |mov locals, rdi
  |.endmacro
  |.macro epilogue
    |pop locals
    |pop r9
    |pop r8
    |pop rcx
    |pop rdx
    |pop rsi
    |pop rdi
    |ret
  |.endmacro
  |.macro ccall
  |add locals, nregs*8
  |.endmacro
  |.macro cret
  |sub locals, nregs*8
  |ret
  |.endmacro

  |.type locals, size_t *, rbx

  dasm_State** Dst = &d;
  |.code
  |->main:
  |prologue
  size_t index = 0;
  size_t nregs = 0;
  size_t cfunc = 0;
  while(index < nops) {
    switch(ops[index++]) {
    case VM_OPCODE_EXIT: {
      |epilogue
      break;
    }
    case VM_OPCODE_REG: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t inreg = ops[index++];
      |mov rax, [locals + inreg * 8]
      |mov aword [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_INT: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t num = ops[index++];
      |mov aword [locals + reg * 8], num
      break;
    }
    case VM_OPCODE_RETURN: {
      vm_opcode_t reg = ops[index++];
      |mov rax, [locals + reg * 8]
      |cret
      break;
    }
    case VM_OPCODE_ADD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |add rax, [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_SUB: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |sub rax, [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_MUL: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |mul aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_DIV: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      |mov rax, [locals + lhs * 8]
      |div aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_MOD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      |mov rax, [locals + lhs * 8]
      |div aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rdx
      break;
    }
    case VM_OPCODE_BB: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + reg * 8]
      |test rax, rax
      if (jfalse == index) {
        |jnz =>jtrue
      } else if (jtrue == index) {
        |jz =>jfalse
      } else {
        |jz =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_LT: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      |jae >1
      |mov aword [locals + outreg * 8], 1
      |jmp >2
      |1:
      |mov aword [locals + outreg * 8], 0
      |2:
      break;
    }
    case VM_OPCODE_EQ: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      |je >1
      |mov aword [locals + outreg * 8], 1
      |jmp >2
      |1:
      |mov aword [locals + outreg * 8], 0
      |2:
      break;
    }
    case VM_OPCODE_CALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      if (nargs >= 7) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      if (nargs >= 1) {
        vm_opcode_t arg = ops[index++];
        |mov arg1, [locals + arg * 8]
      }
      if (nargs >= 2) {
        vm_opcode_t arg = ops[index++];
        |mov arg2, [locals + arg * 8]
      }
      if (nargs >= 3) {
        vm_opcode_t arg = ops[index++];
        |mov arg3, [locals + arg * 8]
      }
      if (nargs >= 4) {
        vm_opcode_t arg = ops[index++];
        |mov arg4, [locals + arg * 8]
      }
      if (nargs >= 5) {
        vm_opcode_t arg = ops[index++];
        |mov arg5, [locals + arg * 8]
      }
      if (nargs >= 6) {
        vm_opcode_t arg = ops[index++];
        |mov arg6, [locals + arg * 8]
      }
      |call =>func-1
      |mov [locals + rreg*8], rax
      break;
    }
    case VM_OPCODE_TCALL: {
      vm_opcode_t nargs = ops[index++];
      if (nargs >= 7) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      if (nargs >= 1) {
        vm_opcode_t arg = ops[index++];
        |mov arg1, [locals + arg * 8]
      }
      if (nargs >= 2) {
        vm_opcode_t arg = ops[index++];
        |mov arg2, [locals + arg * 8]
      }
      if (nargs >= 3) {
        vm_opcode_t arg = ops[index++];
        |mov arg3, [locals + arg * 8]
      }
      if (nargs >= 4) {
        vm_opcode_t arg = ops[index++];
        |mov arg4, [locals + arg * 8]
      }
      if (nargs >= 5) {
        vm_opcode_t arg = ops[index++];
        |mov arg5, [locals + arg * 8]
      }
      if (nargs >= 6) {
        vm_opcode_t arg = ops[index++];
        |mov arg6, [locals + arg * 8]
      }
      if (nargs >= 1) {
        |mov [locals + 8], arg1
      }
      if (nargs >= 2) {
        |mov [locals + 16], arg2
      }
      if (nargs >= 3) {
        |mov [locals + 24], arg3
      }
      if (nargs >= 4) {
        |mov [locals + 32], arg4
      }
      if (nargs >= 5) {
        |mov [locals + 40], arg5
      }
      if (nargs >= 6) {
        |mov [locals + 48], arg6
      }
      |jmp =>cfunc
      break;
    }
    case VM_OPCODE_DCALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      if (nargs >= 7) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      if (nargs >= 1) {
        vm_opcode_t arg = ops[index++];
        |mov arg1, [locals + arg * 8]
      }
      if (nargs >= 2) {
        vm_opcode_t arg = ops[index++];
        |mov arg2, [locals + arg * 8]
      }
      if (nargs >= 3) {
        vm_opcode_t arg = ops[index++];
        |mov arg3, [locals + arg * 8]
      }
      if (nargs >= 4) {
        vm_opcode_t arg = ops[index++];
        |mov arg4, [locals + arg * 8]
      }
      if (nargs >= 5) {
        vm_opcode_t arg = ops[index++];
        |mov arg5, [locals + arg * 8]
      }
      if (nargs >= 6) {
        vm_opcode_t arg = ops[index++];
        |mov arg6, [locals + arg * 8]
      }
      |call aword [locals + func * 8]
      |mov [locals + rreg*8], rax
      break;
    }
    case VM_OPCODE_INTF: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t func = ops[index++];
      |lea rax, [=>func-1]
      |mov aword [locals + reg * 8], rax
      break;
    }
    case VM_OPCODE_PUTCHAR: {
      vm_opcode_t inreg = ops[index++];
      |mov rax, &putchar
      |mov rdi, [locals + inreg * 8]
      |call rax
      break;
    }
    case VM_OPCODE_JUMP: {
      vm_opcode_t over = ops[index++];
      |jmp =>over
      break;
    }
    case VM_OPCODE_FUNC: {
      vm_opcode_t over = ops[index++];
      vm_opcode_t nargs = ops[index++];
      nregs = ops[index++];
      |jmp =>over
      |=>index-1:
      |ccall
      if (nargs >= 1) {
        |mov [locals + 8], arg1
      }
      if (nargs >= 2) {
        |mov [locals + 16], arg2
      }
      if (nargs >= 3) {
        |mov [locals + 24], arg3
      }
      if (nargs >= 4) {
        |mov [locals + 32], arg4
      }
      if (nargs >= 5) {
        |mov [locals + 40], arg5
      }
      if (nargs >= 6) {
        |mov [locals + 48], arg6
      }
      if (nargs >= 7) {
        printf("func needs too many args\n");
        return 1;
      }
      cfunc = index;
      break;
    }
    case VM_OPCODE_ADDI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |add rax, rhs
      |mov [locals + out * 8], rax
      break;
    }
    case VM_OPCODE_SUBI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |sub rax, rhs
      |mov [locals + out * 8], rax
      break;
    }
    case VM_OPCODE_BEQ: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      if (jfalse == index) {
        |jne =>jtrue
      } else if (jtrue == index) {
        |je =>jfalse
      } else {
        |je =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_BLT: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      if (jfalse == index) {
        |jb =>jtrue
      } else if (jtrue == index) {
        |jae =>jfalse
      } else {
        |jae =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_RETI: {
      vm_opcode_t num = ops[index++];
      |mov rax, num
      |cret
      break;
    }
    case VM_OPCODE_BEQI: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, rhs
      if (jfalse == index) {
        |jne =>jtrue
      } else if (jtrue == index) {
        |je =>jfalse
      } else {
        |je =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    default:
      return ops[index - 1] + 100;
    }
    |=>index:
  }
  size_t sz;
  void* buf;
  dasm_link(&d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  dasm_free(&d);
  void(*fn)(size_t*) = labels[lbl_main];
  size_t *regs = vm_malloc(sizeof(size_t) * (1 << 20));
  fn(regs);
  vm_free(regs);
  munmap(buf, sz);
  return 0;
}