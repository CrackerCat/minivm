
#include <stdio.h>
#include <stdlib.h>
#include "../luajit/dynasm/dasm_proto.h"
#include "../luajit/dynasm/dasm_x86.h"
#include <sys/mman.h>

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "vm.h"
#include "lib.h"

#define MAX_NESTING 100

struct vm_state_t;
typedef struct vm_state_t vm_state_t;

int vm_run(size_t nops, const vm_opcode_t *ops)
{
  dasm_State* d;
  |.arch x64
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist vm_actions
  dasm_setup(&d, vm_actions);
  dasm_growpc(&d, nops);
  |.macro prologue
    |push rax
    |push rcx
    |push rdx
    |push rbx
    |push rdi
  |.endmacro
  |.macro epilogue
    |pop rdi
    |pop rbx
    |pop rdx
    |pop rcx
    |pop rax
    |ret
  |.endmacro

  |.type locals, size_t *, rdi

  dasm_State** Dst = &d;
  |.code
  |->main:
  |prologue
  size_t index = 0;
  size_t nregs = 0;
  size_t cfunc = 0;
  while(index < nops) {
    switch(ops[index++]) {
    case VM_OPCODE_EXIT: {
      |epilogue
      break;
    }
    case VM_OPCODE_REG: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t inreg = ops[index++];
      |mov rax, [locals + inreg * 8]
      |mov aword [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_INT: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t num = ops[index++];
      |mov aword [locals + reg * 8], num
      break;
    }
    case VM_OPCODE_RETURN: {
      vm_opcode_t reg = ops[index++];
      |mov rax, [locals + reg * 8]
      |pop locals
      |ret
      break;
    }
    case VM_OPCODE_ADD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |add rax, [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_SUB: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |sub rax, [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_MUL: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |mul aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_DIV: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      |mov rax, [locals + lhs * 8]
      |div aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_MOD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      |mov rax, [locals + lhs * 8]
      |div aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rdx
      break;
    }
    case VM_OPCODE_BB: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + reg * 8]
      |test rax, rax
      if (jfalse == index) {
        |jnz =>jtrue
      } else if (jtrue == index) {
        |jz =>jfalse
      } else {
        |jz =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_LT: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      |jae >1
      |mov aword [locals + outreg * 8], 1
      |jmp >2
      |1:
      |mov aword [locals + outreg * 8], 0
      |2:
      break;
    }
    case VM_OPCODE_EQ: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      |je >1
      |mov aword [locals + outreg * 8], 1
      |jmp >2
      |1:
      |mov aword [locals + outreg * 8], 0
      |2:
      break;
    }
    case VM_OPCODE_CALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      switch (nargs) {
      case 0: {
        |call =>func-1
        break;
      }
      case 1: {
        vm_opcode_t arg1 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |call =>func-1
        break;
      }
      case 2: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |call =>func-1
        break;
      }
      case 3: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |call =>func-1
        break;
      }
      case 4: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        vm_opcode_t arg4 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |mov rbx, [locals + arg4 * 8]
        |call =>func-1
        break;
      }
      default: {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      }
      |mov [locals + rreg*8], rax
      break;
    }
    case VM_OPCODE_TCALL: {
      vm_opcode_t nargs = ops[index++];
      switch (nargs) {
      case 0: {
        |jmp =>cfunc
        break;
      }
      case 1: {
        vm_opcode_t arg1 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov [locals + 8], rax
        |jmp =>cfunc
        break;
      }
      case 2: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov [locals + 8], rax
        |mov [locals + 16], rcx
        |jmp =>cfunc
        break;
      }
      case 3: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |mov [locals + 8], rax
        |mov [locals + 16], rcx
        |mov [locals + 24], rdx
        |jmp =>cfunc
        break;
      }
      case 4: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        vm_opcode_t arg4 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |mov rbx, [locals + arg4 * 8]
        |mov [locals + 8], rax
        |mov [locals + 16], rcx
        |mov [locals + 24], rdx
        |mov [locals + 245], rbx
        |jmp =>cfunc
        break;
      }
      default: {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      }
      break;
    }
    case VM_OPCODE_DCALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      switch (nargs) {
      case 0: {
        |call aword [locals + func * 8]
        break;
      }
      case 1: {
        vm_opcode_t arg1 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |call aword [locals + func * 8]
        break;
      }
      case 2: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |call aword [locals + func * 8]
        break;
      }
      case 3: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |call aword [locals + func * 8]
        break;
      }
      case 4: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        vm_opcode_t arg4 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |mov rbx, [locals + arg4 * 8]
        |call aword [locals + func * 8]
        break;
      }
      default: {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 1;
      }
      }
      |mov [locals + rreg*8], rax
      break;
    }
    case VM_OPCODE_INTF: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t func = ops[index++];
      |lea rax, [=>func-1]
      |mov aword [locals + reg * 8], rax
      break;
    }
    case VM_OPCODE_PUTCHAR: {
      vm_opcode_t inreg = ops[index++];
      |push locals
      |mov rax, &putchar
      |mov locals, [locals + inreg * 8]
      |call rax
      |pop locals
      break;
    }
    case VM_OPCODE_JUMP: {
      vm_opcode_t over = ops[index++];
      |jmp =>over
      break;
    }
    case VM_OPCODE_FUNC: {
      vm_opcode_t over = ops[index++];
      vm_opcode_t nargs = ops[index++];
      vm_opcode_t nregs = ops[index++];
      |jmp =>over
      |=>index-1:
      |push locals
      |add locals, nregs*8
      if (nargs >= 1) {
        |mov [locals + 8], rax
      }
      if (nargs >= 2) {
        |mov [locals + 16], rcx
      }
      if (nargs >= 3) {
        |mov [locals + 24], rdx
      }
      if (nargs >= 4) {
        |mov [locals + 32], rbx
      }
      if (nargs >= 5) {
        printf("func needs too many args\n");
        return 1;
      }
      cfunc = index;
      break;
    }
    case VM_OPCODE_ADDI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |add rax, rhs
      |mov [locals + out * 8], rax
      break;
    }
    case VM_OPCODE_SUBI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |sub rax, rhs
      |mov [locals + out * 8], rax
      break;
    }
    case VM_OPCODE_BEQ: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      if (jfalse == index) {
        |jne =>jtrue
      } else if (jtrue == index) {
        |je =>jfalse
      } else {
        |je =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_BLT: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      if (jfalse == index) {
        |jb =>jtrue
      } else if (jtrue == index) {
        |jae =>jfalse
      } else {
        |jae =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_RETI: {
      vm_opcode_t num = ops[index++];
      |mov rax, num
      |pop locals
      |ret
      break;
    }
    case VM_OPCODE_BEQI: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, rhs
      if (jfalse == index) {
        |jne =>jtrue
      } else if (jtrue == index) {
        |je =>jfalse
      } else {
        |je =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    default:
      return ops[index - 1] + 100;
    }
    |=>index:
  }
  size_t sz;
  void* buf;
  dasm_link(&d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  dasm_free(&d);
  void(*fn)(size_t*) = labels[lbl_main];
  size_t *regs = vm_malloc(sizeof(size_t) * (1 << 20));
  fn(regs);
  vm_free(regs);
  munmap(buf, sz);
  return 0;
}