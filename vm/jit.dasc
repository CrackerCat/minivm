
#include <stdio.h>
#include <stdlib.h>
#include "../luajit/dynasm/dasm_proto.h"
#include "../luajit/dynasm/dasm_x86.h"
#include <sys/mman.h>

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "vm.h"
#include "lib.h"

static void* link_and_encode(dasm_State** d)
{
  size_t sz;
  void* buf;
  dasm_link(d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  return buf;
}

#define MAX_NESTING 100

struct vm_state_t;
typedef struct vm_state_t vm_state_t;

int vm_run(size_t nops, const vm_opcode_t *ops)
{
  dasm_State* d;
  |.arch x64
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist vm_actions
  dasm_setup(&d, vm_actions);
  dasm_growpc(&d, nops);
  |.macro prologue
    |push rax
    |push rcx
    |push rdx
    |push rbx
    |push rdi
  |.endmacro
  |.macro epilogue
    |pop rdi
    |pop rbx
    |pop rdx
    |pop rcx
    |pop rax
    |ret
  |.endmacro

  |.type locals, size_t *, rdi

  dasm_State** Dst = &d;
  |.code
  |->main:
  |prologue
  size_t index = 0;
  size_t nregs = 0;
  while(index < nops) {
    switch(ops[index++]) {
    case VM_OPCODE_EXIT: {
      |mov rax, &exit
      |mov rdi, 0
      |call rax
      break;
    }
    case VM_OPCODE_REG: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t inreg = ops[index++];
      |mov rax, [locals + inreg * 8]
      |mov aword [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_INT: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t num = ops[index++];
      |mov aword [locals + reg * 8], num
      break;
    }
    case VM_OPCODE_RETURN: {
      vm_opcode_t reg = ops[index++];
      |mov rax, [locals + reg * 8]
      |pop locals
      |ret
      break;
    }
    case VM_OPCODE_ADD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |add rax, [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_SUB: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |sub rax, [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_MUL: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |mul aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_DIV: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      |mov rax, [locals + lhs * 8]
      |div aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rax
      break;
    }
    case VM_OPCODE_MOD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      |mov rax, [locals + lhs * 8]
      |div aword [locals + rhs * 8]
      |mov [locals + outreg * 8], rdx
      break;
    }
    case VM_OPCODE_BB: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      |mov rax, [locals + reg * 8]
      |test rax, rax
      |jz =>jfalse
      |jmp =>jtrue
      break;
    }
    case VM_OPCODE_LT: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      |jae >1
      |mov aword [locals + outreg * 8], 1
      |jmp >2
      |1:
      |mov aword [locals + outreg * 8], 0
      |2:
      break;
    }
    case VM_OPCODE_EQ: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |mov rax, [locals + lhs * 8]
      |cmp rax, [locals + rhs * 8]
      |je >1
      |mov aword [locals + outreg * 8], 1
      |jmp >2
      |1:
      |mov aword [locals + outreg * 8], 0
      |2:
      break;
    }
    case VM_OPCODE_CALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      switch (nargs) {
      case 0: {
        |call =>func-1
        break;
      }
      case 1: {
        vm_opcode_t arg1 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |call =>func-1
        break;
      }
      case 2: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |call =>func-1
        break;
      }
      case 3: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |call =>func-1
        break;
      }
      case 4: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        vm_opcode_t arg4 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |mov rbx, [locals + arg4 * 8]
        |call =>func-1
        break;
      }
      default: {
        printf("bad nregs: %hu\n", nargs);
        return 42;
      }
      }
      |mov [locals + rreg*8], rax
      break;
    }
    case VM_OPCODE_DCALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      |mov r9, [locals + func * 8]
      switch (nargs) {
      case 0: {
        |call aword [locals + func * 8]
        break;
      }
      case 1: {
        vm_opcode_t arg1 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |call aword [locals + func * 8]
        break;
      }
      case 2: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |call aword [locals + func * 8]
        break;
      }
      case 3: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |call aword [locals + func * 8]
        break;
      }
      case 4: {
        vm_opcode_t arg1 = ops[index++]; 
        vm_opcode_t arg2 = ops[index++]; 
        vm_opcode_t arg3 = ops[index++]; 
        vm_opcode_t arg4 = ops[index++]; 
        |mov rax, [locals + arg1 * 8]
        |mov rcx, [locals + arg2 * 8]
        |mov rdx, [locals + arg3 * 8]
        |mov rbx, [locals + arg4 * 8]
        |call aword [locals + func * 8]
        break;
      }
      default: {
        printf("bad nregs: %hu\n", nargs);
        return 1;
      }
      }
      |mov [locals + rreg*8], rax
      break;
    }
    case VM_OPCODE_INTF: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t func = ops[index++];
      |lea rax, [=>func-1]
      |mov aword [locals + reg * 8], rax
      break;
    }
    case VM_OPCODE_PUTCHAR: {
      vm_opcode_t inreg = ops[index++];
      |push locals
      |mov rax, &putchar
      |mov locals, [locals + inreg * 8]
      |call rax
      |pop locals
      break;
    }
    case VM_OPCODE_JUMP: {
      vm_opcode_t over = ops[index++];
      |jmp =>over
      break;
    }
    case VM_OPCODE_FUNC: {
      vm_opcode_t over = ops[index++];
      vm_opcode_t nargs = ops[index++];
      vm_opcode_t nregs = ops[index++];
      |jmp =>over
      |=>index-1:
      |push locals
      |add locals, nregs*8
      if (nargs >= 1) {
        |mov [locals + 8], rax
      }
      if (nargs >= 2) {
        |mov [locals + 16], rcx
      }
      if (nargs >= 3) {
        |mov [locals + 24], rdx
      }
      if (nargs >= 4) {
        |mov [locals + 32], rbx
      }
      if (nargs >= 5) {
        printf("func needs too many args\n");
        return 1;
      }
      break;
    }
    default:
      return ops[index - 1] + 100;
    }
    |=>index:
  }
  |epilogue
  link_and_encode(&d);
  dasm_free(&d);
  void(*fn)(size_t*) = labels[lbl_main];
  size_t *regs = vm_malloc(sizeof(size_t) * (1 << 16));
  fn(regs);
  return 0;
}