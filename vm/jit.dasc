
#include <stdio.h>
#include <stdlib.h>
#include "../luajit/dynasm/dasm_proto.h"
#include "../luajit/dynasm/dasm_x86.h"
#include <sys/mman.h>

|.arch x64

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "vm.h"
#include "lib.h"

#define MAX_NESTING 100

struct vm_state_t;
typedef struct vm_state_t vm_state_t;

#define VM_RAX 0
#define VM_RCX 1
#define VM_RDX 2
#define VM_RBX 3
#define VM_RSP 4
#define VM_RBP 5
#define VM_RSI 6
#define VM_RDI 7

#define VM_ARG1 VM_RDI
#define VM_ARG2 VM_RSI
#define VM_ARG3 VM_RDX
#define VM_ARG4 VM_RCX
#define VM_ARG5 VM_RBP

|.macro prologue
  |push rdi
  |push rsi
  |push rdx
  |push rcx
  |push r8
  |push r9  
  |push rbx
  |push rbp
  |mov rbx, rdi
|.endmacro
|.macro epilogue
  |pop rbp
  |pop rbx
  |pop r9
  |pop r8
  |pop rcx
  |pop rdx
  |pop rsi
  |pop rdi
  |ret
|.endmacro

static void rtov(dasm_State **Dst, vm_opcode_t vreg, int x64reg) {
  if (vreg < 8) {
    |mov Rq(vreg+8), Rq(x64reg)
  } else {
    |mov aword [rbx + (vreg-8) * 8], Rq(x64reg)
  }
}

static void vtor(dasm_State **Dst, int x64reg, vm_opcode_t vreg) {
  if (vreg < 8) {
    |mov Rq(x64reg), Rq(vreg+8)
  } else {
    |mov Rq(x64reg), aword [rbx + (vreg-8) * 8]
  }
}

int vm_run(size_t nops, const vm_opcode_t *ops)
{
  dasm_State* d;
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist vm_actions
  dasm_setup(&d, vm_actions);
  dasm_growpc(&d, nops);

  dasm_State** Dst = &d;
  |.code
  |->main:
  |prologue
  size_t index = 0;
  size_t nregs = 0;
  size_t cfunc = 0;
  size_t alloc = 0;
  while(index < nops) {
    switch(ops[index++]) {
    case VM_OPCODE_EXIT: {
      |epilogue
      break;
    }
    case VM_OPCODE_REG: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t inreg = ops[index++];
      if (inreg < 8) {
        if (outreg < 8) {
          |mov Rq(outreg+8), Rq(inreg+8)
        } else {
          rtov(Dst, outreg, inreg+8);
        }
      } else {
        if (outreg < 8) {
          vtor(Dst, VM_RAX, inreg);
        } else {
          vtor(Dst, VM_RAX, inreg);
          rtov(Dst, outreg, VM_RAX);
        }
      }
      break;
    }
    case VM_OPCODE_INT: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t num = ops[index++];
      if (reg < 8) {
        |mov Rq(reg+8), num
      } else {
        |mov rax, num
        rtov(Dst, reg, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_RETURN: {
      vm_opcode_t reg = ops[index++];
      vtor(Dst, VM_RAX, reg);
      if (nregs > 8) {
        |sub rbx, (nregs - 8)*8
      }
      |ret
      break;
    }
    case VM_OPCODE_ADD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vtor(Dst, VM_RAX, lhs);
      if (rhs < 8) {
        |add rax, Rq(rhs+8)
      } else {
        vtor(Dst, VM_RCX, rhs);
        |add rax, rcx
      }
      rtov(Dst, outreg, VM_RAX);
      break;
    }
    case VM_OPCODE_SUB: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vtor(Dst, VM_RAX, lhs);
      if (rhs < 8) {
        |add rax, Rq(rhs+8)
      } else {
        vtor(Dst, VM_RCX, rhs);
        |sub rax, rcx
      }
      rtov(Dst, outreg, VM_RAX);
      break;
    }
    case VM_OPCODE_MUL: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vtor(Dst, VM_RAX, lhs);
      if (rhs < 8) {
        |mul Rq(rhs+8)
      } else {
        vtor(Dst, VM_RCX, rhs);
        |mul rcx
      }
      rtov(Dst, outreg, VM_RAX);
      break;
    }
    case VM_OPCODE_DIV: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      vtor(Dst, VM_RAX, lhs);
      if (rhs < 8) {
        |div Rq(rhs+8)
      } else {
        vtor(Dst, VM_RCX, rhs);
        |div rcx
      }
      rtov(Dst, outreg, VM_RAX);
      break;
    }
    case VM_OPCODE_MOD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      vtor(Dst, VM_RAX, lhs);
      if (rhs < 8) {
        |div Rq(rhs+8)
      } else {
        vtor(Dst, VM_RCX, rhs);
        |div rcx
      }
      rtov(Dst, outreg, VM_RDX);
      break;
    }
    case VM_OPCODE_BB: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (reg < 8) {
        |test Rq(reg+8), Rq(reg+8)
      } else {
        vtor(Dst, VM_RAX, reg);
        |test rax, rax
      }
      if (jfalse == index) {
        |jnz =>jtrue
      } else if (jtrue == index) {
        |jz =>jfalse
      } else {
        |jnz =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_CALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      if (nargs > 5) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      int max = 0;
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        |push Rq(i+8)
        max = i;
      }
      if (nargs >= 1) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG1, arg);
      }
      if (nargs >= 2) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG2, arg);
      }
      if (nargs >= 3) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG3, arg);
      }
      if (nargs >= 4) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG4, arg);
      }
      if (nargs >= 5) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG5, arg);
      }
      |call =>func-1
      for (int i = max; i >= 0; i--) {
        |pop Rq(i+8)
      }
      rtov(Dst, rreg, VM_RAX);
      break;
    }
    case VM_OPCODE_DCALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      if (nargs > 5) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      int max = 0;
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        |push Rq(i+8)
        max = i;
      }
      if (nargs >= 1) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG1, arg);
      }
      if (nargs >= 2) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG2, arg);
      }
      if (nargs >= 3) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG3, arg);
      }
      if (nargs >= 4) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG4, arg);
      }
      if (nargs >= 5) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG5, arg);
      }
      vtor(Dst, VM_RAX, func);
      |call rax
      for (int i = max; i >= 0; i--) {
        |pop Rq(i+8)
      }
      rtov(Dst, rreg, VM_RAX);
      break;
    }
    case VM_OPCODE_TCALL: {
      vm_opcode_t nargs = ops[index++];
      if (nargs > 4) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      if (nargs >= 1) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG1, arg);
      }
      if (nargs >= 2) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG2, arg);
      }
      if (nargs >= 3) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG3, arg);
      }
      if (nargs >= 4) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG4, arg);
      }
      if (nargs >= 5) {
        vm_opcode_t arg = ops[index++];
        vtor(Dst, VM_ARG5, arg);
      }
      if (nargs >= 1) {
        rtov(Dst, 1, VM_ARG1);
      }
      if (nargs >= 2) {
        rtov(Dst, 2, VM_ARG2);
      }
      if (nargs >= 3) {
        rtov(Dst, 3, VM_ARG3);
      }
      if (nargs >= 4) {
        rtov(Dst, 4, VM_ARG4);
      }
      if (nargs >= 5) {
        rtov(Dst, 5, VM_ARG5);
      }
      |jmp =>cfunc
      break;
    }
    case VM_OPCODE_INTF: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t func = ops[index++];
      |lea rax, [=>func-1]
      rtov(Dst, reg, VM_RAX);
      break;
    }
    case VM_OPCODE_PUTCHAR: {
      vm_opcode_t inreg = ops[index++];
      |mov rax, &putchar
      vtor(Dst, VM_RDI, inreg);
      |call rax
      break;
    }
    case VM_OPCODE_JUMP: {
      vm_opcode_t over = ops[index++];
      |jmp =>over
      break;
    }
    case VM_OPCODE_FUNC: {
      vm_opcode_t over = ops[index++];
      vm_opcode_t nargs = ops[index++];
      nregs = ops[index++];
      |jmp =>over
      |=>index-1:
      if (nregs > 8) {
        |add rbx, (nregs - 8) * 8
      }
      if (nargs > 5) {
        printf("func needs too many args\n");
        return 1;
      }
      if (nargs >= 1) {
        rtov(Dst, 1, VM_ARG1);
      }
      if (nargs >= 2) {
        rtov(Dst, 2, VM_ARG2);
      }
      if (nargs >= 3) {
        rtov(Dst, 3, VM_ARG3);
      }
      if (nargs >= 4) {
        rtov(Dst, 4, VM_ARG4);
      }
      if (nargs >= 5) {
        rtov(Dst, 5, VM_ARG5);
      }
      cfunc = index;
      break;
    }
    case VM_OPCODE_ADDI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      if (out == lhs) {
        if (rhs == 1) {
          |inc Rq(lhs+8)
        } else {
          |add Rq(lhs+8), rhs
        }
      } else {
        vtor(Dst, VM_RAX, lhs);
        if (rhs == 1) {
          |inc rax        
        } else if (rhs != 0) {
          |add rax, rhs
        }
        rtov(Dst, out, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_SUBI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      if (out == lhs) {
        if (rhs == 1) {
          |dec Rq(lhs+8)
        } else {
          |sub Rq(lhs+8), rhs
        }
      } else {
        vtor(Dst, VM_RAX, lhs);
        if (rhs == 1) {
          |dec rax        
        } else if (rhs != 0) {
          |sub rax, rhs
        }
        rtov(Dst, out, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_BEQ: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      int rlhs;
      if (lhs < 8) {
        rlhs = lhs + 8;
      } else {
        rlhs = VM_RAX;
        vtor(Dst, VM_RAX, lhs);
      }
      int rrhs;
      if (rhs < 8) {
        rrhs = rhs + 8;
      } else {
        rrhs = VM_RCX;
        vtor(Dst, VM_RCX, rhs);
      }
      |cmp Rq(rlhs), Rq(rrhs)
      if (jfalse == index) {
        |je =>jtrue
      } else if (jtrue == index) {
        |jne =>jfalse
      } else {
        |je =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_BLT: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      int rlhs;
      if (lhs < 8) {
        rlhs = lhs + 8;
      } else {
        rlhs = VM_RAX;
        vtor(Dst, VM_RAX, lhs);
      }
      int rrhs;
      if (rhs < 8) {
        rrhs = rhs + 8;
      } else {
        rrhs = VM_RCX;
        vtor(Dst, VM_RCX, rhs);
      }
      |cmp Rq(rlhs), Rq(rrhs)
      if (jfalse == index) {
        |jb =>jtrue
      } else if (jtrue == index) {
        |jnb =>jfalse
      } else {
        |jb =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_RETI: {
      vm_opcode_t num = ops[index++];
      |mov rax, num
      if (nregs > 8) {
        |sub rbx, (nregs - 8)*8
      }
      |ret
      break;
    }
    case VM_OPCODE_BEQI: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (lhs < 8) {
        |cmp Rq(lhs+8), rhs
      } else {
        vtor(Dst, VM_RAX, lhs);
        |cmp rax, rhs
      }
      if (jfalse == index) {
        |jne =>jtrue
      } else if (jtrue == index) {
        |je =>jfalse
      } else {
        |je =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    default:
      return ops[index - 1] + 100;
    }
    |=>index:
  }
  size_t sz;
  void* buf;
  dasm_link(&d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  dasm_free(&d);
  void(*fn)(size_t*) = labels[lbl_main];
  size_t *regs = vm_malloc(sizeof(size_t) * (1 << 20));
  fn(regs);
  vm_free(regs);
  munmap(buf, sz);
  return 0;
}