
#include <stdio.h>
#include <stdlib.h>
#include "../../luajit/dynasm/dasm_proto.h"
#include "../../luajit/dynasm/dasm_x86.h"
#include <sys/mman.h>

|.arch x64

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "../vm.h"

#define VM_RAX 0
#define VM_RCX 1
#define VM_RDX 2
#define VM_RBX 3
#define VM_RSP 4
#define VM_RBP 5
#define VM_RSI 6
#define VM_RDI 7
#define VM_R8 8
#define VM_R9 9
#define VM_R10 10
#define VM_R11 11
#define VM_R12 12
#define VM_R13 13
#define VM_R14 14
#define VM_R15 15

#define VM_TMP1 VM_RDX

|.macro prologue
  |push rbp
  |mov rbp, rdi
|.endmacro
|.macro epilogue
  |pop rbp
  |ret
|.endmacro

#define VM_XREG(vreg) (vm_xreg(vreg))

static int vm_xreg(int r) {
  switch (r) {
  case 0: return VM_R8;
  case 1: return VM_R9;
  case 2: return VM_R10;
  case 3: return VM_R11;
  case 4: return VM_R12;
  case 5: return VM_R13;
  case 6: return VM_R14;
  case 7: return VM_R15;
  default: __builtin_trap();
  }
}

static int vm_arg_reg(int narg) {
  switch(narg) {
  case 0: return VM_RDI;
  case 1: return VM_RSI;
  case 2: return VM_RDX;
  case 3: return VM_RCX;
  case 4: return VM_RDX;
  case 5: return VM_RBX;
  default: __builtin_trap();
  }
}

#define rtov(vreg, xreg) (vm_rtov(Dst, vreg, xreg))
static void vm_rtov(dasm_State **Dst, vm_opcode_t vreg, int x64reg) {
  if (vreg < 8) {
    if (vreg + 8 != x64reg) {
      |mov Rq(VM_XREG(vreg)), Rq(x64reg)
    }
  } else {
    |mov aword [rbp + (vreg-8) * 8], Rq(x64reg)
  }
}

#define vtor(xreg, vreg) (vm_vtor(Dst, xreg, vreg))
static void vm_vtor(dasm_State **Dst, int x64reg, vm_opcode_t vreg) {
  if (vreg < 8) {
    if (vreg + 8 != x64reg) {
      |mov Rq(x64reg), Rq(VM_XREG(vreg))
    }
  } else {
    |mov Rq(x64reg), aword [rbp + (vreg-8) * 8]
  }
}

int vm_run(size_t nops, const vm_opcode_t *ops) {
  dasm_State* d;
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist vm_actions
  dasm_setup(&d, vm_actions);
  dasm_growpc(&d, nops);

  dasm_State** Dst = &d;
  |.code
  |->main:
  |prologue
  size_t index = 0;
  size_t nregs = 0;
  size_t cfunc = 0;
  while(index < nops) {
    switch(ops[index++]) {
    case VM_OPCODE_EXIT: {
      |epilogue
      break;
    }
    case VM_OPCODE_REG: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t inreg = ops[index++];
      if (inreg < 8) {
        if (outreg < 8) {
          |mov Rq(VM_XREG(outreg)), Rq(VM_XREG(inreg))
        } else {
          rtov(outreg, VM_XREG(inreg));
        }
      } else {
        if (outreg < 8) {
          vtor(VM_XREG(outreg), inreg);
        } else {
          vtor(VM_TMP1, inreg);
          rtov(outreg, VM_TMP1);
        }
      }
      break;
    }
    case VM_OPCODE_INT: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t num = ops[index++];
      if (reg < 8) {
        |mov Rq(VM_XREG(reg)), num
      } else {
        |mov Rq(VM_TMP1), num
        rtov(reg, VM_TMP1);
      }
      break;
    }
    case VM_OPCODE_RETURN: {
      vm_opcode_t reg = ops[index++];
      vtor(VM_TMP1, reg);
      if (nregs > 8) {
        |sub rbp, (nregs - 8)*8
      }
      |ret
      break;
    }
    case VM_OPCODE_ADD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vtor(VM_TMP1, lhs);
      if (rhs < 8) {
        |add Rq(VM_TMP1), Rq(VM_XREG(rhs))
      } else {
        vtor(VM_RCX, rhs);
        |add Rq(VM_TMP1), rcx
      }
      rtov(outreg, VM_TMP1);
      break;
    }
    case VM_OPCODE_SUB: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vtor(VM_TMP1, lhs);
      if (rhs < 8) {
        |add Rq(VM_TMP1), Rq(VM_XREG(rhs))
      } else {
        vtor(VM_RCX, rhs);
        |sub Rq(VM_TMP1), rcx
      }
      rtov(outreg, VM_TMP1);
      break;
    }
    case VM_OPCODE_MUL: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vtor(VM_RAX, lhs);
      if (rhs < 8) {
        |mul Rq(VM_XREG(rhs))
      } else {
        vtor(VM_RCX, rhs);
        |mul rcx
      }
      rtov(outreg, VM_RAX);
      break;
    }
    case VM_OPCODE_DIV: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      vtor(VM_RAX, lhs);
      if (rhs < 8) {
        |div Rq(VM_XREG(rhs))
      } else {
        vtor(VM_RCX, rhs);
        |div rcx
      }
      rtov(outreg, VM_RAX);
      break;
    }
    case VM_OPCODE_MOD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      |xor edx, edx
      vtor(VM_RAX, lhs);
      if (rhs < 8) {
        |div Rq(VM_XREG(rhs))
      } else {
        vtor(VM_RCX, rhs);
        |div rcx
      }
      rtov(outreg, VM_RDX);
      break;
    }
    case VM_OPCODE_BB: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (reg < 8) {
        |test Rq(VM_XREG(reg)), Rq(VM_XREG(reg))
      } else {
        vtor(VM_TMP1, reg);
        |test Rq(VM_TMP1), Rq(VM_TMP1)
      }
      if (jfalse == index) {
        |jnz =>jtrue
      } else if (jtrue == index) {
        |jz =>jfalse
      } else {
        |jnz =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_CALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      if (nargs > 6) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 1;
      }
      int max = 0;
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        if (i != rreg) {
          |push Rq(VM_XREG(i))
        }
        max = i;
      }
      int spill = 0;
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i];
        if (1 <= arg && arg <= i) {
          vtor(vm_arg_reg(spill++), arg);
        } else {
          vtor(9+i, arg);
        }
      }
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i];
        if (1 <= arg && arg <= i) {
          |mov Rq(9+i), Rq(vm_arg_reg(--spill))
        }
      }
      index += nargs;
      |call =>func-1
      for (int i = max; i >= 0; i--) {
        if (i != rreg) {
          |pop Rq(VM_XREG(i))
        }
      }
      rtov(rreg, VM_TMP1);
      break;
    }
    case VM_OPCODE_DCALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      if (nargs > 6) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      int max = 0;
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        if (i != rreg) {
          |push Rq(VM_XREG(i))
        }
        max = i;
      }
      int spill = 0;
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i];
        if (1 <= arg && arg <= i) {
          if (arg != i+1) {
            vtor(vm_arg_reg(spill++), arg);
          }
        } else {
          vtor(9+i, arg);
        }
      }
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i];
        if (1 <= arg && arg <= i) {
          if (arg != i+1) {
            |mov Rq(9+i), Rq(vm_arg_reg(--spill))
          }
        }
      }
      index += nargs;
      vtor(VM_TMP1, func);
      |call Rq(VM_TMP1)
      for (int i = max; i >= 0; i--) {
        if (i != rreg) {
          |pop Rq(VM_XREG(i))
        }
      }
      rtov(rreg, VM_TMP1);
      break;
    }
    case VM_OPCODE_TCALL: {
      vm_opcode_t nargs = ops[index++];
      if (nargs > 6) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 1;
      }
      int spill = 0;
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i];
        if (1 <= arg && arg <= i) {
          vtor(vm_arg_reg(spill++), arg);
        } else {
          vtor(9+i, arg);
        }
      }
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i];
        if (1 <= arg && arg <= i) {
          |mov Rq(9+i), Rq(vm_arg_reg(--spill))
        }
      }
      index += nargs;
      |jmp =>cfunc
      break;
    }
    case VM_OPCODE_INTF: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t func = ops[index++];
      |lea Rq(VM_TMP1), [=>func-1]
      rtov(reg, VM_TMP1);
      break;
    }
    case VM_OPCODE_PUTCHAR: {
      vm_opcode_t inreg = ops[index++];
      |mov Rq(VM_TMP1), &putchar
      vtor(VM_RDI, inreg);
      |call Rq(VM_TMP1)
      break;
    }
    case VM_OPCODE_JUMP: {
      vm_opcode_t over = ops[index++];
      |jmp =>over
      break;
    }
    case VM_OPCODE_FUNC: {
      vm_opcode_t over = ops[index++];
      vm_opcode_t nargs = ops[index++];
      nregs = ops[index++];
      |jmp =>over
      |=>index-1:
      if (nregs > 8) {
        |add rbp, (nregs - 8) * 8
      }
      if (nargs > 6) {
        printf("func needs too many args\n");
        return 1;
      }
      cfunc = index;
      break;
    }
    case VM_OPCODE_ADDI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      if (out == lhs) {
        if (rhs == 1) {
          |inc Rq(VM_XREG(out))
        } else {
          |add Rq(VM_XREG(out)), rhs
        }
      } else if (out < 8) {
        vtor(VM_XREG(out), lhs);
        if (rhs == 1) {
          |inc Rq(VM_XREG(out))
        } else {
          |add Rq(VM_XREG(out)), rhs
        }
      } else {
        vtor(VM_TMP1, lhs);
        if (rhs == 1) {
          |inc Rq(VM_TMP1)        
        } else if (rhs != 0) {
          |add Rq(VM_TMP1), rhs
        }
        rtov(out, VM_TMP1);
      }
      break;
    }
    case VM_OPCODE_SUBI: {
      vm_opcode_t out = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      if (out == lhs) {
        if (rhs == 1) {
          |dec Rq(VM_XREG(out))
        } else {
          |sub Rq(VM_XREG(out)), rhs
        }
      } else if (out < 8) {
        vtor(VM_XREG(out), lhs);
        if (rhs == 1) {
          |dec Rq(VM_XREG(out))
        } else {
          |sub Rq(VM_XREG(out)), rhs
        }
      } else {
        vtor(VM_TMP1, lhs);
        if (rhs == 1) {
          |dec Rq(VM_TMP1)        
        } else if (rhs != 0) {
          |sub Rq(VM_TMP1), rhs
        }
        rtov(out, VM_TMP1);
      }
      break;
    }
    case VM_OPCODE_BEQ: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      int rlhs;
      if (lhs < 8) {
        rlhs = lhs + 8;
      } else {
        rlhs = VM_TMP1;
        vtor(VM_TMP1, lhs);
      }
      int rrhs;
      if (rhs < 8) {
        rrhs = rhs + 8;
      } else {
        rrhs = VM_RCX;
        vtor(VM_RCX, rhs);
      }
      |cmp Rq(rlhs), Rq(rrhs)
      if (jfalse == index) {
        |je =>jtrue
      } else if (jtrue == index) {
        |jne =>jfalse
      } else {
        |je =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_BLT: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      int rlhs;
      if (lhs < 8) {
        rlhs = lhs + 8;
      } else {
        rlhs = VM_TMP1;
        vtor(VM_TMP1, lhs);
      }
      int rrhs;
      if (rhs < 8) {
        rrhs = rhs + 8;
      } else {
        rrhs = VM_RCX;
        vtor(VM_RCX, rhs);
      }
      |cmp Rq(rlhs), Rq(rrhs)
      if (jfalse == index) {
        |jb =>jtrue
      } else if (jtrue == index) {
        |jnb =>jfalse
      } else {
        |jb =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_RETI: {
      vm_opcode_t num = ops[index++];
      |mov Rq(VM_TMP1), num
      if (nregs > 8) {
        |sub rbp, (nregs - 8)*8
      }
      |ret
      break;
    }
    case VM_OPCODE_BEQI: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (lhs < 8) {
        |cmp Rq(VM_XREG(lhs)), rhs
      } else {
        vtor(VM_TMP1, lhs);
        |cmp Rq(VM_TMP1), rhs
      }
      if (jfalse == index) {
        |jne =>jtrue
      } else if (jtrue == index) {
        |je =>jfalse
      } else {
        |je =>jfalse
        |jmp =>jtrue
      }
      break;
    }
    case VM_OPCODE_BLTI: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (lhs < 8) {
        |cmp Rq(VM_XREG(lhs)), rhs
      } else {
        vtor(VM_TMP1, lhs);
        |cmp Rq(VM_TMP1), rhs
      }
      if (jfalse == index) {
        |jb =>jtrue
      } else if (jtrue == index) {
        |jnb =>jfalse
      } else {
        |jb =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_MULI: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      int shift = 0;
      for (size_t i = 1; i < 31; i++) {
        if (rhs == (1 << i)) {
          shift = i;
          break;
        }
      }
      if (shift > 0) {
        if (lhs == outreg) {
          if (outreg < 8) {
            |shl Rq(VM_XREG(outreg)), shift
          } else {
            |shl aword [rbp + (outreg-8)*8], shift
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          |shl Rq(VM_XREG(outreg)), shift
        } else {
          vtor(VM_TMP1, lhs);
          |shl Rq(VM_TMP1), shift
          rtov(outreg, VM_TMP1);
        }
      } else {
        vtor(VM_RAX, lhs);
        |mov ecx, rhs
        |mul rcx
        rtov(outreg, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_DIVI: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      int shift = 0;
      for (size_t i = 1; i < 31; i++) {
        if (rhs == (1 << i)) {
          shift = i;
          break;
        }
      }
      if (shift > 0) {
        if (lhs == outreg) {
          if (outreg < 8) {
            |shr Rq(VM_XREG(outreg)), shift
          } else {
            |shr aword [rbp + (outreg-8)*8], shift
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          |shr Rq(VM_XREG(outreg)), shift
        } else {
          vtor(VM_TMP1, lhs);
          |shr Rq(VM_TMP1), shift
          rtov(outreg, VM_TMP1);
        }
      } else {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        |mov ecx, rhs
        |div rcx
        rtov(outreg, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_MODI: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      int shift = 0;
      for (size_t i = 1; i < 31; i++) {
        if (rhs == (1 << i)) {
          shift = i;
          break;
        }
      }
      if (shift > 0) {
        if (lhs == outreg) {
          |and Rq(VM_XREG(outreg)), (1<<shift)-1 
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          |and Rq(VM_XREG(outreg)), (1<<shift)-1
        } else {
          vtor(VM_TMP1, lhs);
          |and Rq(VM_TMP1), (1<<shift)-1
          rtov(lhs, VM_TMP1);
        }
      } else {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        |mov ecx, rhs
        |div rcx
        rtov(outreg, VM_RDX);
      }
      break;
    }
    default:
      return ops[index - 1] + 100;
    }
    |=>index:
  }
  size_t sz;
  void* buf;
  dasm_link(&d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  // for (size_t i = 0; i < sz; i++) {
  //   uint8_t mem = ((uint8_t*)buf)[i];
  //   if (mem < 16) {
  //     printf("0");
  //   }
  //   printf("%X ", (unsigned int) mem);
  //   if (i % 8 == 7) {
  //     printf("\n");
  //   }
  // }
  // printf("\n");
  // FILE *outfile = fopen("out.o", "wb");
  // fwrite(buf, sizeof(uint8_t), sz, outfile);
  // fclose(outfile);
  dasm_free(&d);
  void(*fn)(size_t*) = labels[lbl_main];
  size_t *regs = vm_malloc(sizeof(size_t) * (1 << 16));
  fn(regs);
  vm_free(regs);
  munmap(buf, sz);
  return 0;
}