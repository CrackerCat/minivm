
#include "../../luajit/dynasm/dasm_proto.h"
#include "../../luajit/dynasm/dasm_x86.h"

#include "../lib.h"
#include "../vm.h"
#include "../jump.h"
#include "../reguse.h"

|.arch x64

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif


#define VM_RAX 0
#define VM_RCX 1
#define VM_RDX 2
#define VM_RBX 3
#define VM_RSP 4
#define VM_RBP 5
#define VM_RSI 6
#define VM_RDI 7
#define VM_R8 8
#define VM_R9 9
#define VM_R10 10
#define VM_R11 11
#define VM_R12 12
#define VM_R13 13
#define VM_R14 14
#define VM_R15 15

#define VM_TMP1 VM_RDX
#define VM_RREG VM_R8

|.macro prologue
  |push rbp
  |push rbx
  |mov rbp, rdi
|.endmacro
|.macro epilogue
  |pop rbx
  |pop rbp
  |ret
|.endmacro

#define VM_XREG(vreg) (vm_xreg(vreg))

static int vm_xreg(int r) {
  switch (r) {
  case 0: return VM_R8;
  case 1: return VM_R9;
  case 2: return VM_R10;
  case 3: return VM_R11;
  case 4: return VM_R12;
  case 5: return VM_R13;
  case 6: return VM_R14;
  case 7: return VM_R15;
  default: __builtin_trap();
  }
}

static int vm_arg_reg(int narg) {
  switch(narg) {
  case 0: return VM_RDI;
  case 1: return VM_RSI;
  case 2: return VM_RDX;
  case 3: return VM_RCX;
  case 4: return VM_RDX;
  case 5: return VM_RBX;
  default: __builtin_trap();
  }
}

#define rtov(vreg, xreg) (vm_rtov(Dst, vreg, xreg))
static void vm_rtov(dasm_State **Dst, vm_opcode_t vreg, int x64reg) {
  if (vreg < 8) {
    if (VM_XREG(vreg) != x64reg) {
      |mov Rq(VM_XREG(vreg)), Rq(x64reg)
    }
  } else {
    |mov aword [rbp + (vreg-8) * 8], Rq(x64reg)
  }
}

#define vtor(xreg, vreg) (vm_vtor(Dst, xreg, vreg))
static void vm_vtor(dasm_State **Dst, int x64reg, vm_opcode_t vreg) {
  if (vreg < 8) {
    if (VM_XREG(vreg) != x64reg) {
      |mov Rq(x64reg), Rq(VM_XREG(vreg))
    }
  } else {
    |mov Rq(x64reg), aword [rbp + (vreg-8) * 8]
  }
}

int vm_x86_emit(dasm_State** Dst, size_t nops, const vm_opcode_t *ops, size_t index, uint8_t *jumps) {
  size_t nregs = 0;
  size_t cfunc = 0;
  size_t cend = 0;
  uint8_t named[1 << 12] = {0};
  vm_opcode_t regs[1 << 12] = {0};
  while(index < nops) {
    while (index < cend && (jumps[index] & VM_JUMP_REACH) == 0 && ops[index] != VM_OPCODE_FUNC) {
      index++;
      while ((jumps[index] & VM_JUMP_INSTR) == 0) {
        index++;
      }
      |=>index:
    }
    switch(ops[index++]) {
    case VM_OPCODE_EXIT: {
      |epilogue
      break;
    }
    case VM_OPCODE_REG: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t inreg = ops[index++];
      if (inreg < 8) {
        if (outreg < 8) {
          |mov Rq(VM_XREG(outreg)), Rq(VM_XREG(inreg))
        } else {
          rtov(outreg, VM_XREG(inreg));
        }
      } else {
        if (outreg < 8) {
          vtor(VM_XREG(outreg), inreg);
        } else {
          vtor(VM_TMP1, inreg);
          rtov(outreg, VM_TMP1);
        }
      }
      break;
    }
    case VM_OPCODE_INT: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t num = ops[index++];
      named[reg] = 1;
      regs[reg] = num;
      break;
    }
    case VM_OPCODE_RET: {
      vm_opcode_t reg = ops[index++];
      if (named[reg]) {
        |mov Rd(VM_RREG), regs[reg]
      } else {
        vtor(VM_RREG, reg);
      }
      if (nregs > 8) {
        |sub rbp, (nregs - 8)*8
      }
      |ret
      break;
    }
    case VM_OPCODE_ADD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      uint8_t nlhs = named[lhs];
      uint8_t nrhs = named[rhs];
      named[outreg] = 0;
      if (nlhs) {
        if (nrhs) {
          named[outreg] = 1;
          regs[outreg] = regs[lhs] + regs[rhs];
        } else if (outreg == rhs) {
          if (outreg < 8) {
            |add Rq(VM_XREG(outreg)), regs[lhs]
          } else {
            |add aword [rbp + (outreg-8) * 8], regs[lhs]
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), rhs);
          |add Rq(VM_XREG(outreg)), regs[lhs]
        } else {
          vtor(VM_TMP1, rhs);
          |add Rq(VM_TMP1), regs[lhs]
          rtov(outreg, VM_TMP1);
        }
      } else if (nrhs) {
        if (outreg == lhs) {
          if (outreg < 8) {
            |add Rq(VM_XREG(outreg)), regs[rhs]
          } else {
            |add aword [rbp + (outreg-8) * 8], regs[rhs]
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          |add Rq(VM_XREG(outreg)), regs[rhs]
        } else {
          vtor(VM_TMP1, lhs);
          |add Rq(VM_TMP1), regs[rhs]
          rtov(outreg, VM_TMP1);
        }
      } else {
        if (outreg == lhs && outreg < 8) {
          if (rhs < 8) {
            |add Rq(VM_XREG(outreg)), Rq(VM_XREG(rhs))
          } else {
            |add Rq(VM_XREG(outreg)), aword [rbp + (rhs-8) * 8]
          }
        } else if (outreg == rhs && outreg < 8) {
          if (rhs < 8) {
            |add Rq(VM_XREG(outreg)), Rq(VM_XREG(lhs))
          } else {
            |add Rq(VM_XREG(outreg)), aword [rbp + (lhs-8) * 8]
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          if (rhs < 8) {
            |add Rq(VM_XREG(outreg)), Rq(VM_XREG(rhs))
          } else {
            |add Rq(VM_XREG(outreg)), aword [rbp + (rhs-8) * 8]
          }
        } else {
          vtor(VM_TMP1, lhs);
          if (rhs < 8) {
            |add Rq(VM_TMP1), Rq(VM_XREG(rhs))
          } else {
            |add Rq(VM_TMP1), aword [rbp + (rhs-8) * 8]
          }
          rtov(outreg, VM_TMP1);
        }
      }
      break;
    }
    case VM_OPCODE_SUB: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      uint8_t nlhs = named[lhs];
      uint8_t nrhs = named[rhs];
      named[outreg] = 0;
      if (nlhs) {
        if (nrhs) {
          named[outreg] = 1;
          regs[outreg] = regs[lhs] - regs[rhs];
        } else if (outreg == lhs && outreg < 8) {
          |mov Rq(VM_XREG(outreg)), regs[lhs]
          |sub Rq(VM_XREG(outreg)), rhs
        } else {
          vtor(VM_TMP1, rhs);
          |sub Rq(VM_TMP1), regs[lhs]
          rtov(outreg, VM_TMP1);
        }
      } else if (nrhs) {
        if (outreg == lhs) {
          if (outreg < 8) {
            |sub Rq(VM_XREG(outreg)), regs[rhs]
          } else {
            |sub aword [rbp + (outreg-8) * 8], regs[rhs]
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          |sub Rq(VM_XREG(outreg)), regs[rhs]
        } else {
          vtor(VM_TMP1, lhs);
          |sub Rq(VM_TMP1), regs[rhs]
          rtov(outreg, VM_TMP1);
        }
      } else {
        if (outreg == lhs && outreg < 8) {
          if (rhs < 8) {
            |sub Rq(VM_XREG(outreg)), Rq(VM_XREG(rhs))
          } else {
            |sub Rq(VM_XREG(outreg)), aword [rbp + (rhs-8) * 8]
          }
        } else if (outreg == rhs && outreg < 8) {
          if (rhs < 8) {
            |sub Rq(VM_XREG(outreg)), Rq(VM_XREG(lhs))
          } else {
            |sub Rq(VM_XREG(outreg)), aword [rbp + (lhs-8) * 8]
          }
        } else if (outreg < 8) {
          vtor(VM_XREG(outreg), lhs);
          if (rhs < 8) {
            |sub Rq(VM_XREG(outreg)), Rq(VM_XREG(rhs))
          } else {
            |sub Rq(VM_XREG(outreg)), aword [rbp + (rhs-8) * 8]
          }
        } else {
          vtor(VM_TMP1, lhs);
          if (rhs < 8) {
            |sub Rq(VM_TMP1), Rq(VM_XREG(rhs))
          } else {
            |sub Rq(VM_TMP1), aword [rbp + (rhs-8) * 8]
          }
          rtov(outreg, VM_TMP1);
        }
      }
      break;
    }
    case VM_OPCODE_MUL: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      uint8_t nlhs = named[lhs];
      uint8_t nrhs = named[rhs];
      named[outreg] = 0;
      if (nlhs) {
        if (nrhs) {
          named[outreg] = 1;
          regs[outreg] = regs[lhs] / regs[rhs];
        } else {
          if (rhs < 8) {
            |xor edx, edx
            |mov eax, regs[lhs]
            |mul Rq(VM_XREG(rhs))
            rtov(outreg, VM_RAX);
          } else {
            |xor edx, edx
            |mov eax, regs[lhs]
            |mul aword [rbx + (rhs-8) * 8]
            rtov(outreg, VM_RAX);
          }
        }
      } else if (nrhs) {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        |mov Rd(VM_RCX), regs[rhs]
        |mul Rq(VM_RCX)
        rtov(outreg, VM_RAX);
      } else {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        if (rhs < 8) {
          |mul Rq(VM_XREG(rhs))
        } else {
          |mul aword [rbx + (rhs-8) * 8]
        }
        rtov(outreg, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_DIV: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      uint8_t nlhs = named[lhs];
      uint8_t nrhs = named[rhs];
      named[outreg] = 0;
      if (nlhs) {
        if (nrhs) {
          named[outreg] = 1;
          regs[outreg] = regs[lhs] / regs[rhs];
        } else {
          if (rhs < 8) {
            |xor edx, edx
            |mov eax, regs[lhs]
            |div Rq(VM_XREG(rhs))
            rtov(outreg, VM_RAX);
          } else {
            |xor edx, edx
            |mov eax, regs[lhs]
            |div aword [rbx + (rhs-8) * 8]
            rtov(outreg, VM_RAX);
          }
        }
      } else if (nrhs) {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        |mov Rd(VM_RCX), regs[rhs]
        |div Rq(VM_RCX)
        rtov(outreg, VM_RAX);
      } else {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        if (rhs < 8) {
          |div Rq(VM_XREG(rhs))
        } else {
          |div aword [rbx + (rhs-8) * 8]
        }
        rtov(outreg, VM_RAX);
      }
      break;
    }
    case VM_OPCODE_MOD: {
      vm_opcode_t outreg = ops[index++];
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      uint8_t nlhs = named[lhs];
      uint8_t nrhs = named[rhs];
      named[outreg] = 0;
      if (nlhs) {
        if (nrhs) {
          named[outreg] = 1;
          regs[outreg] = regs[lhs] / regs[rhs];
        } else {
          if (rhs < 8) {
            |xor edx, edx
            |mov eax, regs[lhs]
            |div Rq(VM_XREG(rhs))
            rtov(outreg, VM_RDX);
          } else {
            |xor edx, edx
            |mov eax, regs[lhs]
            |div aword [rbx + (rhs-8) * 8]
            rtov(outreg, VM_RDX);
          }
        }
      } else if (nrhs) {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        |mov Rd(VM_RCX), regs[rhs]
        |div Rq(VM_RCX)
        rtov(outreg, VM_RDX);
      } else {
        |xor edx, edx
        vtor(VM_RAX, lhs);
        if (rhs < 8) {
          |div Rq(VM_XREG(rhs))
        } else {
          |div aword [rbx + (rhs-8) * 8]
        }
        rtov(outreg, VM_RDX);
      }
      break;
    }
    case VM_OPCODE_BB: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (named[reg]) {
        if (regs[reg]) {
          |jmp =>jtrue
        } else {
          |jmp =>jfalse
        }
      } else {
        if (reg < 8) {
          |test Rq(VM_XREG(reg)), Rq(VM_XREG(reg))
        } else {
          vtor(VM_TMP1, reg);
          |test Rq(VM_TMP1), Rq(VM_TMP1)
        }
        if (jfalse == index) {
          |jnz =>jtrue
        } else if (jtrue == index) {
          |jz =>jfalse
        } else {
          |jnz =>jtrue
          |jmp =>jfalse
        }
      }
      break;
    }
    case VM_OPCODE_CALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      index += nargs;
      if (nargs > 6) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 1;
      }
      uint8_t used[8] = {0};
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        used[i] = VM_REG_IS_USED(index, i);
      }
      int max = 0;
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        if (i != rreg && used[i]) {
          |push Rq(VM_XREG(i))
        }
        max = i;
      }
      int spill = 0;
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i-nargs];
        if (named[arg]) {
          if (1 <= arg && arg <= i) {
            |mov Rd(vm_arg_reg(spill++)), regs[arg];
          } else {
            |mov Rd(VM_XREG(i+1)), regs[arg];
          }
        } else {
          if (1 <= arg && arg <= i) {
            vtor(vm_arg_reg(spill++), arg);
          } else {
            vtor(VM_XREG(i+1), arg);
          }
        }
      }
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i-nargs];
        if (1 <= arg && arg <= i) {
          |mov Rq(VM_XREG(i+1)), Rq(vm_arg_reg(--spill))
        }
      }
      |call =>func-1
      rtov(rreg, VM_RREG);
      for (int i = max; i >= 0; i--) {
        if (i != rreg && used[i]) {
          |pop Rq(VM_XREG(i))
        }
      }
      named[rreg] = 0;
      break;
    }
    case VM_OPCODE_DCALL: {
      vm_opcode_t rreg = ops[index++];
      vm_opcode_t func = ops[index++];
      vm_opcode_t nargs = ops[index++];
      index += nargs;
      if (nargs > 6) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 42;
      }
      uint8_t used[8] = {0};
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        used[i] = VM_REG_IS_USED(index, i);
      }
      int max = 0;
      for (int i = 0; i < 8; i++) {
        if (i >= nregs) {
          break;
        }
        if (i != rreg && used[i]) {
          |push Rq(VM_XREG(i))
        }
        max = i;
      }
      int spill = 0;
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i-nargs];
        if (named[arg]) {
          if (1 <= arg && arg <= i) {
            |mov Rd(vm_arg_reg(spill++)), regs[arg];
          } else {
            |mov Rd(VM_XREG(i+1)), regs[arg];
          }
        } else {
          if (1 <= arg && arg <= i) {
            vtor(vm_arg_reg(spill++), arg);
          } else {
            vtor(VM_XREG(i+1), arg);
          }
        }
      }
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i-nargs];
        if (1 <= arg && arg <= i) {
          |mov Rq(VM_XREG(i+1)), Rq(vm_arg_reg(--spill))
        }
      }
      if (func < 8) {
        |call Rq(VM_XREG(func))
      } else {
        |call aword [rbp + (func-8) * 8]
      }
      rtov(rreg, VM_RREG);
      for (int i = max; i >= 0; i--) {
        if (i != rreg && used[i]) {
          |pop Rq(VM_XREG(i))
        }
      }
      named[rreg] = 0;
      break;
    }
    case VM_OPCODE_TCALL: {
      vm_opcode_t nargs = ops[index++];
      index += nargs;
      if (nargs > 6) {
        printf("bad nregs: %zu\n", (size_t) nargs);
        return 1;
      }
      int spill = 0;
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i-nargs];
        if (named[arg]) {
          if (1 <= arg && arg <= i) {
            |mov Rd(vm_arg_reg(spill++)), regs[arg];
          } else {
            |mov Rd(VM_XREG(i+1)), regs[arg];
          }
        } else {
          if (1 <= arg && arg <= i) {
            vtor(vm_arg_reg(spill++), arg);
          } else {
            vtor(VM_XREG(i+1), arg);
          }
        }
      }
      for (int i = 0; i < nargs; i++) {
        vm_opcode_t arg = ops[index+i-nargs];
        if (1 <= arg && arg <= i) {
          |mov Rq(VM_XREG(i+1)), Rq(vm_arg_reg(--spill))
        }
      }
      |jmp =>cfunc
      break;
    }
    case VM_OPCODE_INTF: {
      vm_opcode_t reg = ops[index++];
      vm_opcode_t func = ops[index++];
      named[reg] = 0;
      |lea Rq(VM_TMP1), [=>func-1]
      rtov(reg, VM_TMP1);
      break;
    }
    case VM_OPCODE_PUTCHAR: {
      vm_opcode_t inreg = ops[index++];
      if (named[inreg]) {
        |mov Rq(VM_TMP1), &putchar
        |mov rdi, regs[inreg]
        |call Rq(VM_TMP1)
      } else {
        |mov Rq(VM_TMP1), &putchar
        vtor(VM_RDI, inreg);
        |call Rq(VM_TMP1)
      }
      break;
    }
    case VM_OPCODE_JUMP: {
      vm_opcode_t over = ops[index++];
      |jmp =>over
      break;
    }
    case VM_OPCODE_FUNC: {
      vm_opcode_t over = ops[index++];
      vm_opcode_t nargs = ops[index++];
      nregs = ops[index++];
      |jmp =>over
      |=>index-1:
      if (nregs > 8) {
        |add rbp, (nregs - 8) * 8
      }
      if (nargs > 6) {
        printf("func needs too many args\n");
        return 1;
      }
      cfunc = index;
      cend = over;
      break;
    }
    case VM_OPCODE_BEQ: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (named[lhs]) {
        if (named[rhs]) {
          if (regs[lhs] == regs[rhs]) {
            |jmp =>jtrue
          } else {
            |jmp =>jfalse
          }
        } else {
          int rrhs;
          if (rhs < 8) {
            rrhs = VM_XREG(rhs);
          } else {
            rrhs = VM_RCX;
            vtor(VM_RCX, rhs);
          }
          |cmp Rq(rrhs), regs[lhs]
        }
      } else if (named[rhs]) {
        int rlhs;
        if (lhs < 8) {
          rlhs = VM_XREG(lhs);
        } else {
          rlhs = VM_TMP1;
          vtor(VM_TMP1, lhs);
        }
        |cmp Rq(rlhs), regs[rhs]
      } else {
        int rlhs;
        if (lhs < 8) {
          rlhs = VM_XREG(lhs);
        } else {
          rlhs = VM_TMP1;
          vtor(VM_TMP1, lhs);
        }
        int rrhs;
        if (rhs < 8) {
          rrhs = VM_XREG(rhs);
        } else {
          rrhs = VM_RCX;
          vtor(VM_RCX, rhs);
        }
        |cmp Rq(rlhs), Rq(rrhs)
      }
      if (jfalse == index) {
        |je =>jtrue
      } else if (jtrue == index) {
        |jne =>jfalse
      } else {
        |je =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    case VM_OPCODE_BLT: {
      vm_opcode_t lhs = ops[index++];
      vm_opcode_t rhs = ops[index++];
      vm_opcode_t jfalse = ops[index++];
      vm_opcode_t jtrue = ops[index++];
      if (named[lhs]) {
        if (named[rhs]) {
          if (regs[lhs] < regs[rhs]) {
            |jmp =>jtrue
          } else {
            |jmp =>jfalse
          }
        } else {
          |mov Rd(VM_TMP1), regs[lhs]
          int rrhs;
          if (rhs < 8) {
            rrhs = VM_XREG(rhs);
          } else {
            rrhs = VM_RCX;
            vtor(VM_RCX, rhs);
          }
          |cmp Rq(VM_TMP1), Rq(rrhs)
        }
      } else if (named[rhs]) {
        int rlhs;
        if (lhs < 8) {
          rlhs = VM_XREG(lhs);
        } else {
          rlhs = VM_TMP1;
          vtor(VM_TMP1, lhs);
        }
        |cmp Rq(rlhs), regs[rhs]
      } else {
        int rlhs;
        if (lhs < 8) {
          rlhs = VM_XREG(lhs);
        } else {
          rlhs = VM_TMP1;
          vtor(VM_TMP1, lhs);
        }
        int rrhs;
        if (rhs < 8) {
          rrhs = VM_XREG(rhs);
        } else {
          rrhs = VM_RCX;
          vtor(VM_RCX, rhs);
        }
        |cmp Rq(rlhs), Rq(rrhs)
      }
      if (jfalse == index) {
        |jb =>jtrue
      } else if (jtrue == index) {
        |jnb =>jfalse
      } else {
        |jb =>jtrue
        |jmp =>jfalse
      }
      break;
    }
    default:
      return 1;
    }
    if ((jumps[index] & VM_JUMP_IN) || (jumps[index] & VM_JUMP_OUT)) {
      for (size_t i = 0; i < nregs; i++) {
        if (!named[i]) {
          continue;
        }
        if (VM_REG_IS_USED(index, i)) {
          if (i < 8) {
            |mov Rd(VM_XREG(i)), regs[i]
          } else {
            |mov aword [rbp + (i-8) * 8], regs[i]
          }
        }
        named[i] = 0;
      }
    }
    |=>index:
  }
  return 0;
}

int vm_run(size_t nops, const vm_opcode_t *ops) {
  uint8_t *jumps = vm_jump_all(nops, ops);
  if (jumps == NULL) {
    return 1;
  }

  dasm_State* d;
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist vm_actions
  dasm_setup(&d, vm_actions);
  dasm_growpc(&d, nops);


  dasm_State** Dst = &d;
  |.code
  |->main:
  |prologue

  int res = vm_x86_emit(&d, nops, ops, 0, jumps);
  vm_free(jumps);
  if (res != 0) {
    return 1;
  }

  size_t sz;
  void* buf;
  dasm_link(&d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(&d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  // for (size_t i = 0; i < sz; i++) {
  //   uint8_t mem = ((uint8_t*)buf)[i];
  //   if (mem < 16) {
  //     printf("0");
  //   }
  //   printf("%X ", (unsigned int) mem);
  //   if (i % 8 == 7) {
  //     printf("\n");
  //   }
  // }
  // printf("\n");
#if defined(VM_INSTR_DUMP)
  FILE *outfile = fopen("out.o", "wb");
  fwrite(buf, sizeof(uint8_t), sz, outfile);
  fclose(outfile);
#endif
  dasm_free(&d);
  void(*fn)(size_t*) = labels[lbl_main];
  size_t *regs = vm_malloc(sizeof(size_t) * (1 << 16));
  fn(regs);
  vm_free(regs);
  munmap(buf, sz);
  return 0;
}