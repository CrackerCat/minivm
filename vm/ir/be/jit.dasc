
#include "jit.h"
#include "../build.h"
#include "../../int/gc.h"

#include "../../../luajit/dynasm/dasm_proto.h"
#include "../../../luajit/dynasm/dasm_x86.h"

#if _WIN32
#include <Windows.h>
#else
#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif

void vm_ir_be_jit_putc(ptrdiff_t n)
{
    printf("%c", (char) n);
}

ptrdiff_t vm_ir_be_jit_len(vm_gc_t *gc, ptrdiff_t ptr)
{
    return gc->buf[(ptr << 1) - 1].header.len << 1;
}

ptrdiff_t vm_ir_be_jit_alloc(vm_gc_t *gc, ptrdiff_t ptr)
{
    return (vm_gc_arr(gc, ptr >> 1) << 1) | 1;
}

ptrdiff_t vm_ir_be_jit_get(vm_gc_t *gc, ptrdiff_t ptr, ptrdiff_t nth)
{
    return gc->buf[(ptr + nth) >> 1].value.ival;
}

void vm_ir_be_jit_set(vm_gc_t *gc, ptrdiff_t ptr, ptrdiff_t nth, ptrdiff_t val)
{
    gc->buf[(ptr + nth) >> 1].value.ival = val;
}


|.arch x64

|.define vmRegTmp1, r8
|.define vmRegTmp2, r9
|.define vmArg1, rdi
|.define vmArg2, rsi
|.define vmArg3, rdx
|.define vmArg4, rcx

|.macro pusha
| push rbp
// || for (size_t i = 10; i < 16; i++)
// ||{
//     | push Rq(i)
// ||}
| push vmArg1
| push vmArg2
| push vmArg3
| push vmArg4
| push vmRegTmp1
| push vmRegTmp2
|.endmacro

|.macro popa
| pop vmRegTmp2
| pop vmRegTmp1
| pop vmArg4
| pop vmArg3
| pop vmArg2
| pop vmArg1
// || for (size_t i = 15; i >= 10; i--)
// ||{
//     | pop Rq(i)
// ||}
| pop rbp
|.endmacro

|.macro vmCall, x64reg
| pusha
| call x64reg
| popa
|.endmacro

|.macro vmPrintDyn, x64reg
| pusha
| mov vmArg2, x64reg
| xor eax, eax
| mov64 vmArg1, (size_t) "[0x%zX]"
| mov64 vmRegTmp2, (size_t) &printf
| call vmRegTmp2
| popa
|.endmacro

|.macro vmLoad, x64reg, vmReg
| mov x64reg, qword [rsp + ((vmReg)) * sizeof(size_t)]
|.endmacro

|.macro vmStore, vmReg, x64reg
| mov qword [rsp + ((vmReg)) * sizeof(size_t)], x64reg
|.endmacro

|.macro vmLoadArg, x64reg, arg
||do
||{
||vm_ir_arg_t *arg_ = (arg);
||switch (arg_->type)
||{
||case VM_IR_ARG_FUNC:
||{
    |lea x64reg, [=>arg_->func->id*2]
    ||break;
||}
||case VM_IR_ARG_REG:
||{
    |vmLoad x64reg, arg_->reg
    ||break;
||}
||case VM_IR_ARG_NUM:
||{
    |mov64 x64reg, arg_->num << 1
    ||break;
||}
||}
||} while (0);
|.endmacro

|.macro vmPrintNum, index
||do
||{
    | pusha
    | xor eax, eax
    | mov vmArg2, index
    | mov64 vmRegTmp2, (size_t) &printf
    | mov64 vmArg1, (size_t) "%zi"
    | call vmRegTmp2
    | popa
||} while (0);
|.endmacro

|.macro vmPrintStr, str
||do
||{
    | pusha
    ||const char *str_ = str;
    ||while (*str_)
    ||{
        | mov vmArg1, (size_t) *str_
        | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_putc 
        | call vmRegTmp1
        ||str_+=1;
    ||}
    | popa
||} while (0);
|.endmacro

static void *link_and_encode(dasm_State **d)
{
    size_t sz;
    void *buf;
    dasm_link(d, &sz);
#ifdef _WIN32
    buf = VirtualAlloc(0, sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#else
    buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
#endif
    dasm_encode(d, buf);
#ifdef _WIN32
    {
        DWORD dwOld;
        VirtualProtect(buf, sz, PAGE_EXECUTE_READ, &dwOld);
    }
#else
    mprotect(buf, sz, PROT_READ | PROT_EXEC);
#endif
    return buf;
}

void vm_ir_be_jit(size_t nops, vm_ir_block_t *blocks)
{
    vm_gc_t gc;
    size_t nregs = 0;
    vm_gc_init(&gc);
    dasm_State *d;
    dasm_State **Dst = &d;
    |.section code
    dasm_init(Dst, DASM_MAXSECTION);
    |.globals lbl_
    void *labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);
    |.actionlist bf_actions
    dasm_setup(Dst, bf_actions);
    dasm_growpc(Dst, nops*2+1);
    |.code
    |->entry:
    // | int 3
    | call =>0
    for (size_t index = 0; index < nops; index++)
    {
        vm_ir_block_t *block = &blocks[index];
        if (block->id != index)
        {
            continue;
        }
        if (block->isfunc || index == 0)
        {
            nregs = block->nregs+1;
            |=>index*2:
            | push rbp
            | mov rbp, rsp
            | sub rsp, (nregs+1) * sizeof(ptrdiff_t)
            for (size_t i = 1; i <= block->nargs; i++)
            {
                | vmStore i, Rq(9+i)
            }
        }
        |=>index*2+1:
        for (size_t ninstr = 0; ninstr < block->len; ninstr++)
        {
            vm_ir_instr_t *instr = block->instrs[ninstr];
            switch (instr->op)
            {
            case VM_IR_IOP_NOP:
            {
                break;
            }
            case VM_IR_IOP_MOVE:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | vmStore instr->out->reg, vmRegTmp1
                break;
            }
            case VM_IR_IOP_ADD:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | vmLoadArg vmRegTmp2, instr->args[1]
                | add vmRegTmp1, vmRegTmp2
                | vmStore instr->out->reg, vmRegTmp1
                break;
            }
            case VM_IR_IOP_SUB:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | vmLoadArg vmRegTmp2, instr->args[1]
                | sub vmRegTmp1, vmRegTmp2
                | vmStore instr->out->reg, vmRegTmp1
                break;
            }
            case VM_IR_IOP_MUL:
            {
                | vmLoadArg rax, instr->args[0]
                | vmLoadArg rdx, instr->args[1]
                | imul rdx
                | shr rax, 1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_DIV:
            {
                | xor edx, edx
                | vmLoadArg rax, instr->args[0]
                | vmLoadArg rcx, instr->args[1]
                | idiv rcx
                | shl rax, 1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_MOD:
            {
                | xor edx, edx
                | vmLoadArg rax, instr->args[0]
                | vmLoadArg rcx, instr->args[1]
                | idiv rcx
                | vmStore instr->out->reg, rdx
                break;
            }
            case VM_IR_IOP_CALL:
            {
                for (size_t arg = 1; instr->args[arg]; arg++)
                {
                    | vmLoadArg Rq(arg+9), instr->args[arg]
                }
                if (instr->args[0]->type == VM_IR_ARG_REG)
                {
                    | vmLoadArg vmRegTmp2, instr->args[0]
                    | call vmRegTmp2
                }
                else if (instr->args[0]->type == VM_IR_ARG_FUNC)
                {
                    | call =>instr->args[0]->func->id*2
                }
                else
                {
                    __builtin_trap();
                }
                if (instr->out != NULL && instr->out->type == VM_IR_ARG_REG)
                {
                    | vmStore instr->out->reg, rax
                }
                break;
            }
            case VM_IR_IOP_ARR:
            {
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_alloc
                | vmCall vmRegTmp1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_GET:
            {
                | vmLoadArg vmArg3, instr->args[1]
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_get
                | vmCall vmRegTmp1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_SET:
            {
                | vmLoadArg vmArg4, instr->args[2]
                | vmLoadArg vmArg3, instr->args[1]
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_set
                | vmCall vmRegTmp1
                break;
            }
            case VM_IR_IOP_LEN:
            {
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_len
                | vmCall vmRegTmp1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_TYPE:
            {
                |vmPrintStr "error: type\n"
                break;
            }
            case VM_IR_IOP_OUT:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | mov vmArg1, vmRegTmp1
                | shr vmArg1, 1
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_putc
                | vmCall vmRegTmp1
                break;
            }
            }
        }
        switch (block->branch->op)
        {
        case VM_IR_BOP_JUMP:
        {
            | jmp =>block->branch->targets[0]->id*2+1;
            break;
        }
        case VM_IR_BOP_BOOL:
        {
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | sar vmRegTmp1, 1
            | test vmRegTmp1, vmRegTmp1
            | jz =>block->branch->targets[0]->id*2+1
            | jmp =>block->branch->targets[1]->id*2+1
            break;
        }
        case VM_IR_BOP_LESS:
        {
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | vmLoadArg vmRegTmp2, block->branch->args[1]
            | cmp vmRegTmp1, vmRegTmp2
            | jl =>block->branch->targets[1]->id*2+1
            | jmp =>block->branch->targets[0]->id*2+1
            break;
        }
        case VM_IR_BOP_EQUAL:
        {
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | vmLoadArg vmRegTmp2, block->branch->args[1]
            | cmp vmRegTmp1, vmRegTmp2
            | je =>block->branch->targets[1]->id*2+1
            | jmp =>block->branch->targets[0]->id*2+1
            break;
        }
        case VM_IR_BOP_RET:
        {
            // | int 3
            // | vmPrintStr "x"
            | vmLoadArg rax, block->branch->args[0]
            | mov rsp, rbp
            | pop rbp
            | ret
            break;
        }
        case VM_IR_BOP_EXIT:
        {
            | mov vmArg1, 0
            | mov64 vmRegTmp1, (size_t) &exit
            | vmCall vmRegTmp1
            break;
        }
        }
    }
    link_and_encode(&d);
    dasm_free(&d);
    void (*fn)(void) = labels[lbl_entry];
    fn();
    fprintf(stderr, "");
}
