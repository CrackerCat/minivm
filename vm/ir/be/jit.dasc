
#include "jit.h"
#include "../build.h"
#include "../../int/gc.h"

#include "../../../luajit/dynasm/dasm_proto.h"
#include "../../../luajit/dynasm/dasm_x86.h"

#if _WIN32
#include <Windows.h>
#else
#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif

#define VM_STACK_OFFSET(n) ((n) * 8)

void vm_ir_be_jit_putc(int n)
{
    putchar(n);
}

ptrdiff_t vm_ir_be_jit_len(vm_gc_t *gc, ptrdiff_t ptr)
{
    return gc->buf[(ptr << 1) - 1].header.len << 1;
}

ptrdiff_t vm_ir_be_jit_alloc(vm_gc_t *gc, ptrdiff_t ptr)
{
    return (vm_gc_arr(gc, ptr >> 1) << 1) | 1;
}

ptrdiff_t vm_ir_be_jit_get(vm_gc_t *gc, ptrdiff_t ptr, ptrdiff_t nth)
{
    return gc->buf[(ptr + nth) >> 1].value.ival;
}

void vm_ir_be_jit_set(vm_gc_t *gc, ptrdiff_t ptr, ptrdiff_t nth, ptrdiff_t val)
{
    gc->buf[(ptr + nth) >> 1].value.ival = val;
}

size_t vm_ir_be_jit_arg_reg(size_t n)
{
    size_t args[] = {
        7,
        6,
        3,
        2,
        8,
        9,
        10,
        11,
    };
    return args[n];
}

|.arch x64

|.define vmRegTmp1, rbx
|.define vmArg1, rdi
|.define vmArg2, rsi
|.define vmArg3, rdx
|.define vmArg4, rcx

|.macro pusha
| push rbp
| push vmArg1
| push vmArg2
| push vmArg3
| push vmArg4
| push vmRegTmp1
|.endmacro

|.macro popa
| pop vmRegTmp1
| pop vmArg4
| pop vmArg3
| pop vmArg2
| pop vmArg1
| pop rbp
|.endmacro

|.macro vmCall, x64reg
| pusha
| call x64reg
| popa
|.endmacro

|.macro vmPrintDyn, x64reg
| pusha
| mov vmArg2, x64reg
| xor eax, eax
| mov64 vmRegTmp1, (size_t) &printf
| mov64 vmArg1, (size_t) "[0x%zX]"
| call vmRegTmp1
| popa
|.endmacro

|.macro vmLoad, x64reg, vmReg
| mov x64reg, qword [rsp + VM_STACK_OFFSET(vmReg)]
|.endmacro

|.macro vmStore, vmReg, x64reg
| mov qword [rsp + VM_STACK_OFFSET(vmReg)], x64reg
|.endmacro

|.macro vmLoadArg, x64reg, arg
||do
||{
||vm_ir_arg_t *arg_ = (arg);
||switch (arg_->type)
||{
||case VM_IR_ARG_FUNC:
||{
    |lea x64reg, [=>arg_->func->id*2]
    ||break;
||}
||case VM_IR_ARG_REG:
||{
    |vmLoad x64reg, arg_->reg
    ||break;
||}
||case VM_IR_ARG_NUM:
||{
    |mov64 x64reg, arg_->num << 1
    ||break;
||}
||}
||} while (0);
|.endmacro

|.macro vmPrintNum, index
||do
||{
    | pusha
    | xor eax, eax
    | mov vmArg2, index
    | mov64 vmRegTmp1, (size_t) &printf
    | mov64 vmArg1, (size_t) "%zi"
    | call vmRegTmp1
    | popa
||} while (0);
|.endmacro

|.macro vmPrintStr, str
||do
||{
    | pusha
    ||const char *str_ = str;
    ||while (*str_)
    ||{
        | mov vmArg1, (size_t) *str_
        | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_putc 
        | call vmRegTmp1
        ||str_+=1;
    ||}
    | popa
||} while (0);
|.endmacro

static void *link_and_encode(dasm_State **d)
{
    size_t sz;
    void *buf;
    dasm_link(d, &sz);
#ifdef _WIN32
    buf = VirtualAlloc(0, sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#else
    buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
#endif
    dasm_encode(d, buf);
#ifdef _WIN32
    {
        DWORD dwOld;
        VirtualProtect(buf, sz, PAGE_EXECUTE_READ, &dwOld);
    }
#else
    mprotect(buf, sz, PROT_READ | PROT_EXEC);
#endif
    return buf;
}

void vm_ir_be_jit_block(dasm_State **Dst, vm_gc_t *gc, size_t *store, vm_ir_block_t *block)
{
    for (size_t ninstr = 0; ninstr < block->len; ninstr++)
    {
        vm_ir_instr_t *instr = block->instrs[ninstr];
        switch (instr->op)
        {
        case VM_IR_IOP_NOP:
        {
            break;
        }
        case VM_IR_IOP_MOVE:
        {
            | vmLoadArg vmRegTmp1, instr->args[0]
            | vmStore instr->out->reg, vmRegTmp1
            break;
        }
        case VM_IR_IOP_ADD:
        {
            | vmLoadArg vmRegTmp1, instr->args[0]
            if (instr->args[1]->type == VM_IR_ARG_REG)
            {
                | add vmRegTmp1, [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
            }
            else if (instr->args[1]->type == VM_IR_ARG_NUM)
            {
                | add vmRegTmp1, instr->args[1]->num * 2
            }
            else
            {
                __builtin_trap();
            }
            | vmStore instr->out->reg, vmRegTmp1
            break;
        }
        case VM_IR_IOP_SUB:
        {
            | vmLoadArg vmRegTmp1, instr->args[0]
            if (instr->args[1]->type == VM_IR_ARG_REG)
            {
                | sub vmRegTmp1, [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
            }
            else if (instr->args[1]->type == VM_IR_ARG_NUM)
            {
                | sub vmRegTmp1, instr->args[1]->num * 2
            }
            else
            {
                __builtin_trap();
            }
            | vmStore instr->out->reg, vmRegTmp1
            break;
        }
        case VM_IR_IOP_MUL:
        {
            | vmLoadArg rax, instr->args[0]
            | vmLoadArg rdx, instr->args[1]
            | imul rdx
            | shr rax, 1
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_DIV:
        {
            | xor edx, edx
            | vmLoadArg rax, instr->args[0]
            | vmLoadArg rcx, instr->args[1]
            | idiv rcx
            | shl rax, 1
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_MOD:
        {
            | xor edx, edx
            | vmLoadArg rax, instr->args[0]
            | vmLoadArg rcx, instr->args[1]
            | idiv rcx
            | vmStore instr->out->reg, rdx
            break;
        }
        case VM_IR_IOP_CALL:
        {
            for (size_t arg = 1; instr->args[arg]; arg++)
            {
                | vmLoadArg Rq(vm_ir_be_jit_arg_reg(arg)), instr->args[arg]
            }
            if (instr->args[0]->type == VM_IR_ARG_REG)
            {
                | call qword [rsp + VM_STACK_OFFSET(instr->args[0]->reg)]
            }
            else if (instr->args[0]->type == VM_IR_ARG_FUNC)
            {
                | call =>instr->args[0]->func->id*2
            }
            else
            {
                __builtin_trap();
            }
            if (instr->out != NULL && instr->out->type == VM_IR_ARG_REG)
            {
                | vmStore instr->out->reg, rax
            }
            break;
        }
        case VM_IR_IOP_ARR:
        {
            | vmLoadArg vmArg2, instr->args[0]
            | mov64 vmArg1, (size_t) gc
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_alloc
            | vmCall vmRegTmp1
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_GET:
        {
            | vmLoadArg vmArg3, instr->args[1]
            | vmLoadArg vmArg2, instr->args[0]
            | mov64 vmArg1, (size_t) gc
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_get
            | vmCall vmRegTmp1
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_SET:
        {
            | vmLoadArg vmArg4, instr->args[2]
            | vmLoadArg vmArg3, instr->args[1]
            | vmLoadArg vmArg2, instr->args[0]
            | mov64 vmArg1, (size_t) gc
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_set
            | vmCall vmRegTmp1
            break;
        }
        case VM_IR_IOP_LEN:
        {
            | vmLoadArg vmArg2, instr->args[0]
            | mov64 vmArg1, (size_t) gc
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_len
            | vmCall vmRegTmp1
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_TYPE:
        {
            |vmPrintStr "error: type\n"
            break;
        }
        case VM_IR_IOP_OUT:
        {
            | vmLoadArg vmArg1, instr->args[0]
            | shr vmArg1, 1
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_putc
            | vmCall vmRegTmp1
            break;
        }
        }
    }
    switch (block->branch->op)
    {
    case VM_IR_BOP_JUMP:
    {
        | jmp =>block->branch->targets[0]->id*2+1;
        break;
    }
    case VM_IR_BOP_BOOL:
    {
        | vmLoadArg vmRegTmp1, block->branch->args[0]
        | sar vmRegTmp1, 1
        | test vmRegTmp1, vmRegTmp1
        | jz =>block->branch->targets[0]->id*2+1
        | jmp =>block->branch->targets[1]->id*2+1
        break;
    }
    case VM_IR_BOP_LESS:
    {
        | vmLoadArg vmRegTmp1, block->branch->args[0]
        if (block->branch->args[1]->type == VM_IR_ARG_REG)
        {
            | cmp vmRegTmp1, [rsp + VM_STACK_OFFSET(block->branch->args[1]->reg)]
        }
        else if (block->branch->args[1]->type == VM_IR_ARG_NUM)
        {
            | cmp vmRegTmp1, block->branch->args[1]->num * 2
        }
        else
        {
            __builtin_trap();
        }
        | jl =>block->branch->targets[1]->id*2+1
        | jmp =>block->branch->targets[0]->id*2+1
        break;
    }
    case VM_IR_BOP_EQUAL:
    {
        | vmLoadArg vmRegTmp1, block->branch->args[0]
        if (block->branch->args[1]->type == VM_IR_ARG_REG)
        {
            | cmp vmRegTmp1, [rsp + VM_STACK_OFFSET(block->branch->args[1]->reg)]
        }
        else if (block->branch->args[1]->type == VM_IR_ARG_NUM)
        {
            | cmp vmRegTmp1, block->branch->args[1]->num * 2
        }
        else
        {
            __builtin_trap();
        }
        | je =>block->branch->targets[1]->id*2+1
        | jmp =>block->branch->targets[0]->id*2+1
        break;
    }
    case VM_IR_BOP_RET:
    {
        | vmLoadArg rax, block->branch->args[0]
        | mov rsp, rbp
        | pop rbp
        | ret
        break;
    }
    case VM_IR_BOP_EXIT:
    {
        | mov64 rax, (size_t) store
        | mov rsp, [rax]
        | ret
        break;
    }
    }
}

void vm_ir_be_jit(size_t nops, vm_ir_block_t *blocks)
{
    vm_gc_t gc;
    size_t nregs = 0;
    vm_gc_init(&gc);
    dasm_State *d;
    dasm_State **Dst = &d;
    |.section code
    dasm_init(Dst, DASM_MAXSECTION);
    |.globals lbl_
    void *labels[lbl__MAX];
    dasm_setupglobal(Dst, labels, lbl__MAX);
    |.actionlist bf_actions
    dasm_setup(Dst, bf_actions);
    dasm_growpc(Dst, nops*2+1);
    size_t out;
    |.code
    |->entry:
    | mov64 rax, (size_t) &out
    | mov [rax], rsp
    | call =>0
    | mov64 rax, (size_t) &out
    | mov rsp, [rax]
    | ret
    for (size_t index = 0; index < nops; index++)
    {
        vm_ir_block_t *block = &blocks[index];
        if (block->id != index)
        {
            continue;
        }
        if (block->isfunc || index == 0)
        {
            nregs = block->nregs+1;
            |=>index*2:
            | push rbp
            | mov rbp, rsp
            | sub rsp, (nregs+1) * sizeof(ptrdiff_t)
            for (size_t i = 1; i <= block->nargs; i++)
            {
                | vmStore i, Rq(vm_ir_be_jit_arg_reg(i))
            }
        }
        |=>index*2+1:
        vm_ir_be_jit_block(Dst, &gc, &out, block);
    }
    link_and_encode(Dst);
    dasm_free(Dst);
    void (*fn)(void) = labels[lbl_entry];
    fn();
}
