
#include "x64.h"
#include "../build.h"
#include "../opt.h"
#include "../../int/gc.h"

#define DASM_FDEF static

#include "../../../luajit/dynasm/dasm_proto.h"
#include "../../../luajit/dynasm/dasm_x86.h"

#if _WIN32
#include <stdio.h>
#include <Windows.h>
#else
#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif

static void vm_ir_be_x64_block(dasm_State **Dst, vm_gc_t *gc, size_t *store, vm_ir_block_t *block);

#define VM_REG_MAX (7)
#define VM_REG_OFFSET(n) ((n) == 0 ? 1 : 16-(n))
#define VM_STACK_OFFSET(n) (((n)-VM_REG_MAX) * 8)

#define VM_RAX 0
#define VM_RCX 1
#define VM_RDX 2
#define VM_RBX 3
#define VM_RSP 4 
#define VM_RBP 5
#define VM_RSI 6
#define VM_RDI 7

static void vm_ir_be_x64_putc(int n)
{
    fprintf(stdout, "%c", n);
}

static ptrdiff_t vm_ir_be_x64_len(vm_gc_t *gc, ptrdiff_t ptr)
{
    return gc->buf[(ptr << 1) - 1].header.len << 1;
}

static ptrdiff_t vm_ir_be_x64_alloc(vm_gc_t *gc, ptrdiff_t ptr)
{
    return (vm_gc_arr(gc, ptr >> 1) << 1) | 1;
}

static ptrdiff_t vm_ir_be_x64_get(vm_gc_t *gc, ptrdiff_t ptr, ptrdiff_t nth)
{
    return gc->buf[(ptr + nth) >> 1].value.ival;
}

static void vm_ir_be_x64_set(vm_gc_t *gc, ptrdiff_t ptr, ptrdiff_t nth, ptrdiff_t val)
{
    gc->buf[(ptr + nth) >> 1].value.ival = val;
}

static size_t vm_ir_be_x64_arg_reg(size_t n)
{
    size_t args[] = {
        7,
        6,
        3,
        2,
        8,
        9,
    };
    return args[n];
}

|.arch x64

|.define vmRegTmp1, rbx
|.define vmArg1, rdi
|.define vmArg2, rsi
|.define vmArg3, rdx
|.define vmArg4, rcx

|.macro vmLoad, x64reg, vmReg
|| if (vmReg < VM_REG_MAX)
|| {
    | mov x64reg, Rq(VM_REG_OFFSET(vmReg))
|| }
|| else
|| {
    | mov x64reg, [rsp + VM_STACK_OFFSET(vmReg)]
|| }
|.endmacro

|.macro vmStore, vmReg, x64reg
|| if (vmReg < VM_REG_MAX)
|| {
    | mov Rq(VM_REG_OFFSET(vmReg)), x64reg
|| }
|| else
|| {
    | mov [rsp + VM_STACK_OFFSET(vmReg)], x64reg
|| }
|.endmacro

|.macro vmLoadArg, x64reg, arg
||do
||{
||vm_ir_arg_t *arg_ = (arg);
||switch (arg_->type)
||{
||case VM_IR_ARG_FUNC:
||{
    | lea x64reg, [=>arg_->func->id*2]
    ||break;
||}
||case VM_IR_ARG_REG:
||{
    | vmLoad x64reg, arg_->reg
    ||break;
||}
||case VM_IR_ARG_NUM:
||{
    || if (arg->num == 0)
    ||{
        | xor x64reg, x64reg
    ||}
    ||else if (arg->num * 2 <= INT32_MAX && arg->num * 2 >= INT32_MIN)
    ||{
        | mov x64reg, arg_->num * 2
    ||}
    ||else
    ||{
        | mov64 x64reg, arg_->num * 2
    ||}
    ||break;
||}
||}
||} while (0);
|.endmacro

static void *link_and_encode(dasm_State **d, size_t *sz)
{
    void* buf;
    dasm_link(d, sz);
#ifdef _WIN32
    buf = VirtualAlloc(0, *sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#else
    buf = mmap(0, *sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
#endif
    dasm_encode(d, buf);
#ifdef _WIN32
    {DWORD dwOld; VirtualProtect(buf, *sz, PAGE_EXECUTE_READ, &dwOld); }
#else
    mprotect(buf, *sz, PROT_READ | PROT_EXEC);
#endif
    return buf;
}

static void vm_ir_be_x64_tcall(dasm_State **Dst, size_t nargs, vm_ir_arg_t **args, size_t *targets)
{
    size_t npush = 0;
    for (ptrdiff_t i = 0; i < nargs; i++)
    {
        if (args[i]->type == VM_IR_ARG_REG && args[i]->reg != targets[i])
        {
            if (npush > 6)
            {
                fprintf(stderr, "register allocation failed in JIT\n");
                __builtin_trap();
            }
            | vmLoad Rq(vm_ir_be_x64_arg_reg(npush)), args[i]->reg
            npush += 1;
        }
    }
    size_t npop = 0;
    for (ptrdiff_t i = 0; i < nargs; i++)
    {
        if (args[i]->type == VM_IR_ARG_REG && args[i]->reg != targets[i])
        {
            // printf("SPILL: r%zu -> r%zu\n", args[i]->reg, targets[i]);
            | vmStore targets[i], Rq(vm_ir_be_x64_arg_reg(npop))
            npop += 1;
        }
    }
}

static void vm_ir_be_x64_jump(dasm_State **Dst, vm_gc_t *gc, size_t *store, vm_ir_block_t *last, vm_ir_block_t *block)
{
    // if (last->id < block->id)
    // {
        // vm_ir_be_x64_block(Dst, gc, store, block);
    // }
    // else
    // {
        | jmp =>block->id*2+1
    // }
}

static void vm_ir_be_x64_block(dasm_State **Dst, vm_gc_t *gc, size_t *store, vm_ir_block_t *block)
{
    for (size_t ninstr = 0; ninstr < block->len; ninstr++)
    {
        vm_ir_instr_t *instr = block->instrs[ninstr];
        switch (instr->op)
        {
        case VM_IR_IOP_NOP:
        {
            break;
        }
        case VM_IR_IOP_MOVE:
        {
            | vmLoadArg vmRegTmp1, instr->args[0]
            | vmStore instr->out->reg, vmRegTmp1
            break;
        }
        case VM_IR_IOP_ADD:
        {
            if (instr->args[0]->type == VM_IR_ARG_REG && instr->args[0]->reg == instr->out->reg)
            {
                if (instr->out->reg < VM_REG_MAX)
                {
                    if (instr->args[1]->type == VM_IR_ARG_NUM)
                    {
                        | add Rq(VM_REG_OFFSET(instr->out->reg)), instr->args[1]->num * 2
                    }
                    else if (instr->args[1]->type != VM_IR_ARG_REG)
                    {
                        __builtin_trap();
                    }
                    else if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | add Rq(VM_REG_OFFSET(instr->out->reg)), Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | add Rq(VM_REG_OFFSET(instr->out->reg)), [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                    }
                }
                else
                {
                    if (instr->args[1]->type == VM_IR_ARG_NUM)
                    {
                        | add qword [rsp + VM_STACK_OFFSET(instr->args[1]->reg)], instr->args[1]->num * 2
                    }
                    else if (instr->args[1]->type != VM_IR_ARG_REG)
                    {
                        __builtin_trap();
                    }
                    else if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | add [rsp + VM_STACK_OFFSET(instr->args[1]->reg)], Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | vmLoadArg vmRegTmp1, instr->args[1]
                        | add [rsp + VM_STACK_OFFSET(instr->args[1]->reg)], vmRegTmp1
                    }
                }
            }
            else
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                if (instr->args[1]->type == VM_IR_ARG_REG)
                {
                    if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | add vmRegTmp1, Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | add vmRegTmp1, [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                    }
                }
                else if (instr->args[1]->type == VM_IR_ARG_NUM)
                {
                    | add vmRegTmp1, instr->args[1]->num * 2
                }
                else
                {
                    __builtin_trap();
                }
                | vmStore instr->out->reg, vmRegTmp1
            }
            break;
        }
        case VM_IR_IOP_SUB:
        {
            if (instr->args[0]->type == VM_IR_ARG_REG && instr->args[0]->reg == instr->out->reg)
            {
                if (instr->out->reg < VM_REG_MAX)
                {
                    if (instr->args[1]->type == VM_IR_ARG_NUM)
                    {
                        | sub Rq(VM_REG_OFFSET(instr->out->reg)), instr->args[1]->num * 2
                    }
                    else if (instr->args[1]->type != VM_IR_ARG_REG)
                    {
                        __builtin_trap();
                    }
                    else if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | sub Rq(VM_REG_OFFSET(instr->out->reg)), Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | sub Rq(VM_REG_OFFSET(instr->out->reg)), [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                    }
                }
                else
                {
                    if (instr->args[1]->type == VM_IR_ARG_NUM)
                    {
                        | sub qword [rsp + VM_STACK_OFFSET(instr->args[1]->reg)], instr->args[1]->num * 2
                    }
                    else if (instr->args[1]->type != VM_IR_ARG_REG)
                    {
                        __builtin_trap();
                    }
                    else if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | sub [rsp + VM_STACK_OFFSET(instr->args[1]->reg)], Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | vmLoadArg vmRegTmp1, instr->args[1]
                        | sub [rsp + VM_STACK_OFFSET(instr->args[1]->reg)], vmRegTmp1
                    }
                }
            }
            else
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                if (instr->args[1]->type == VM_IR_ARG_REG)
                {
                    if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | sub vmRegTmp1, Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | sub vmRegTmp1, [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                    }
                }
                else if (instr->args[1]->type == VM_IR_ARG_NUM)
                {
                    | sub vmRegTmp1, instr->args[1]->num * 2
                }
                else
                {
                    __builtin_trap();
                }
                | vmStore instr->out->reg, vmRegTmp1
            }
            break;
        }
        case VM_IR_IOP_MUL:
        {
            if (instr->args[0]->type == VM_IR_ARG_NUM)
            {

            }
            else if (instr->args[0]->type != VM_IR_ARG_REG)
            {
                __builtin_trap();
            }
            else
            {
                | vmLoad vmRegTmp1, instr->args[0]->reg
                if (instr->args[1]->type == VM_IR_ARG_REG)
                {
                    if (instr->args[1]->reg < VM_REG_MAX)
                    {
                        | imul vmRegTmp1, Rq(VM_REG_OFFSET(instr->args[1]->reg))
                    }
                    else
                    {
                        | imul vmRegTmp1, [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                    }
                    | shr vmRegTmp1, 1
                }
                else if (instr->args[1]->type == VM_IR_ARG_NUM)
                {
                    | imul vmRegTmp1, vmRegTmp1, instr->args[1]->num
                }
                else
                {
                    __builtin_trap();
                }
                | vmStore instr->out->reg, vmRegTmp1
            }
            break;
        }
        case VM_IR_IOP_DIV:
        {
            | xor edx, edx
            | vmLoadArg rax, instr->args[0]
            | vmLoadArg vmRegTmp1, instr->args[1]
            if (instr->args[1]->type == VM_IR_ARG_REG)
            {
                if (instr->args[1]->reg < VM_REG_MAX)
                {
                    | idiv Rq(VM_REG_OFFSET(instr->args[1]->reg))
                }
                else
                {
                    | idiv qword [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                }
                | shl rax, 1
            }
            else if (instr->args[1]->type == VM_IR_ARG_NUM)
            {
                | mov64 vmRegTmp1, instr->args[1]->num
                | idiv vmRegTmp1
            }
            else
            {
                __builtin_trap();
            }
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_MOD:
        {
            | xor edx, edx
            | vmLoadArg rax, instr->args[0]
            if (instr->args[1]->type == VM_IR_ARG_REG)
            {
                if (instr->args[1]->reg < VM_REG_MAX)
                {
                    | idiv Rq(VM_REG_OFFSET(instr->args[1]->reg))
                }
                else
                {
                    | idiv qword [rsp + VM_STACK_OFFSET(instr->args[1]->reg)]
                }
            }
            else if (instr->args[1]->type == VM_IR_ARG_NUM)
            {
                | mov64 vmRegTmp1, instr->args[1]->num*2
                | idiv vmRegTmp1
            }
            else
            {
                __builtin_trap();
            }
            | vmStore instr->out->reg, rdx
            break;
        }
        case VM_IR_IOP_CALL:
        {
            for (size_t arg = 1; instr->args[arg]; arg++)
            {
                | vmLoadArg Rq(vm_ir_be_x64_arg_reg(arg-1)), instr->args[arg]
            }
            uint8_t saved[8] = {0};
            {
                if (instr->out != NULL && instr->out->type == VM_IR_ARG_REG && instr->out->reg < 8 && saved[instr->out->reg] == 0)
                {
                    saved[instr->out->reg] = 1;
                }
                for (size_t seek = ninstr+1; seek < block->len; seek++)
                {
                    vm_ir_instr_t *instr = block->instrs[seek];
                    for (size_t j = 0; instr->args[j] != NULL; j++)
                    {
                        vm_ir_arg_t *arg = instr->args[j];
                        if (arg->type == VM_IR_ARG_REG && arg->reg < 8 && saved[arg->reg] == 0)
                        {
                            saved[arg->reg] = 2;
                        }
                    }
                    if (instr->out != NULL && instr->out->type == VM_IR_ARG_REG && instr->out->reg < 8 && saved[instr->out->reg] == 0)
                    {
                        saved[instr->out->reg] = 1;
                    }
                }
                for (size_t j = 0; j < 2; j++)
                {
                    vm_ir_arg_t *arg = block->branch->args[j];
                    if (arg == NULL)
                    {
                        continue;
                    }
                    if (arg->type == VM_IR_ARG_REG && arg->reg < 8 && saved[arg->reg] == 0)
                    {
                        saved[arg->reg] = 2;
                    }
                }
                for (size_t j = 0; j < 2; j++)
                {
                    vm_ir_block_t *target = block->branch->targets[j];
                    if (target == NULL)
                    {
                        continue;
                    }
                    for (size_t k = 0; k < target->nargs; k++)
                    {
                        size_t arg = target->args[k];
                        if (arg < 8 && saved[arg] == 0)
                        {
                            saved[arg] = 2;
                        }
                    }
                }
            }
            if (instr->args[0]->type == VM_IR_ARG_REG)
            {
                | vmLoad rax, instr->args[0]->reg
            }
            for (size_t i = 0; i < VM_REG_MAX; i++)
            {
                if (saved[i] == 2)
                {
                    | push Rq(VM_REG_OFFSET(i))
                }
            }
            if (instr->args[0]->type == VM_IR_ARG_REG)
            {
                | call rax
            }
            else if (instr->args[0]->type == VM_IR_ARG_FUNC)
            {
                | call =>instr->args[0]->func->id*2
            }
            else
            {
                __builtin_trap();
            }
            for (ptrdiff_t i = VM_REG_MAX-1; i >= 0; i--)
            {
                if (saved[i] == 2)
                {
                    | pop Rq(VM_REG_OFFSET(i))
                }
            }
            if (instr->out != NULL && instr->out->type == VM_IR_ARG_REG)
            {
                | vmStore instr->out->reg, rax
            }
            break;
        }
        case VM_IR_IOP_ARR:
        {
            | mov64 vmArg1, (size_t) gc
            | vmLoadArg vmArg2, instr->args[0]
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_x64_alloc
            | push r11
            | push r10
            | call vmRegTmp1
            | pop r10
            | pop r11
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_GET:
        {
            | mov64 vmArg1, (size_t) gc
            | vmLoadArg vmArg2, instr->args[0]
            | vmLoadArg vmArg3, instr->args[1]
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_x64_get
            | push r11
            | push r10
            | call vmRegTmp1
            | pop r10
            | pop r11
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_SET:
        {
            | mov64 vmArg1, (size_t) gc
            | vmLoadArg vmArg2, instr->args[0]
            | vmLoadArg vmArg3, instr->args[1]
            | vmLoadArg vmArg4, instr->args[2]
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_x64_set
            | push r11
            | push r10
            | call vmRegTmp1
            | pop r10
            | pop r11
            break;
        }
        case VM_IR_IOP_LEN:
        {
            | mov64 vmArg1, (size_t) gc
            | vmLoadArg vmArg2, instr->args[0]
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_x64_len
            | push r11
            | push r10
            | call vmRegTmp1
            | pop r10
            | pop r11
            | vmStore instr->out->reg, rax
            break;
        }
        case VM_IR_IOP_TYPE:
        {
            // |vmPrintStr "error: type\n"
            | int 3
            break;
        }
        case VM_IR_IOP_OUT:
        {
            | vmLoadArg vmArg1, instr->args[0]
            | shr vmArg1, 1
            | mov64 vmRegTmp1, (size_t) &vm_ir_be_x64_putc
            | push r11
            | push r10
            | call vmRegTmp1
            | pop r10
            | pop r11
            break;
        }
        }
    }
    switch (block->branch->op)
    {
    case VM_IR_BOP_JUMP:
    {
        vm_ir_be_x64_tcall(Dst, block->branch->targets[0]->nargs, block->branch->pass[0], block->branch->targets[0]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[0]);
        break;
    }
    case VM_IR_BOP_BOOL:
    {
        | vmLoadArg vmRegTmp1, block->branch->args[0]
        | sar vmRegTmp1, 1
        | test vmRegTmp1, vmRegTmp1
        | jnz >1
        vm_ir_be_x64_tcall(Dst, block->branch->targets[0]->nargs, block->branch->pass[0], block->branch->targets[0]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[0]);
        |1:
        vm_ir_be_x64_tcall(Dst, block->branch->targets[1]->nargs, block->branch->pass[1], block->branch->targets[1]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[1]);
        break;
    }
    case VM_IR_BOP_LESS:
    {
        | vmLoadArg vmRegTmp1, block->branch->args[0]
        if (block->branch->args[1]->type == VM_IR_ARG_REG)
        {
            if (block->branch->args[1]->reg < VM_REG_MAX)
            {
                | cmp vmRegTmp1, Rq(VM_REG_OFFSET(block->branch->args[1]->reg))
            }
            else
            {
                | cmp vmRegTmp1, [rsp + VM_STACK_OFFSET(block->branch->args[1]->reg)]
            }
        }
        else if (block->branch->args[1]->type == VM_IR_ARG_NUM)
        {
            | cmp vmRegTmp1, block->branch->args[1]->num * 2
        }
        else
        {
            __builtin_trap();
        }
        | jl >1
        vm_ir_be_x64_tcall(Dst, block->branch->targets[0]->nargs, block->branch->pass[0], block->branch->targets[0]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[0]);
        |1:
        vm_ir_be_x64_tcall(Dst, block->branch->targets[1]->nargs, block->branch->pass[1], block->branch->targets[1]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[1]);
        break;
    }
    case VM_IR_BOP_EQUAL:
    {
        | vmLoadArg vmRegTmp1, block->branch->args[0]
        if (block->branch->args[1]->type == VM_IR_ARG_REG)
        {
            if (block->branch->args[1]->reg < VM_REG_MAX)
            {
                | cmp vmRegTmp1, Rq(VM_REG_OFFSET(block->branch->args[1]->reg))
            }
            else
            {
                | cmp vmRegTmp1, [rsp + VM_STACK_OFFSET(block->branch->args[1]->reg)]
            }
        }
        else if (block->branch->args[1]->type == VM_IR_ARG_NUM)
        {
            | cmp vmRegTmp1, block->branch->args[1]->num * 2
        }
        else
        {
            __builtin_trap();
        }
        | je >1
        vm_ir_be_x64_tcall(Dst, block->branch->targets[0]->nargs, block->branch->pass[0], block->branch->targets[0]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[0]);
        |1:
        vm_ir_be_x64_tcall(Dst, block->branch->targets[1]->nargs, block->branch->pass[1], block->branch->targets[1]->args);
        vm_ir_be_x64_jump(Dst, gc, store, block, block->branch->targets[1]);
        break;
    }
    case VM_IR_BOP_RET:
    {
        | vmLoadArg rax, block->branch->args[0]
        | mov rsp, rbp
        | pop rbp
        | ret
        break;
    }
    case VM_IR_BOP_EXIT:
    {
        | mov64 rax, (size_t) store
        | mov rsp, [rax]
        | pop r15
        | pop r14
        | pop r13
        | pop r12
        | pop rbp
        | pop rbx
        | ret
        break;
    }
    }
}

void vm_ir_be_x64(size_t nops, vm_ir_block_t *blocks)
{
    vm_gc_t gc;
    size_t nregs = 0;
    vm_gc_init(&gc);
    dasm_State *d;
    dasm_State **Dst = &d;
    |.section code
    dasm_init(Dst, DASM_MAXSECTION);
    |.globals lbl_
    void *labels[lbl__MAX];
    dasm_setupglobal(Dst, labels, lbl__MAX);
    |.actionlist bf_actions
    dasm_setup(Dst, bf_actions);
    dasm_growpc(Dst, nops*2+1);
    size_t out;
    |.code
    |->entry:
    | push rbx
    | push rbp
    | push r12
    | push r13
    | push r14
    | push r15
    | mov64 rax, (size_t) &out
    | mov [rax], rsp
    | call =>0
    | mov64 rax, (size_t) &out
    | mov rsp, [rax]
    | pop r15
    | pop r14
    | pop r13
    | pop r12
    | pop rbp
    | pop rbx
    | ret
    for (size_t index = 0; index < nops; index++)
    {
        vm_ir_block_t *block = &blocks[index];
        if (block->id != index)
        {
            continue;
        }
        if (block->isfunc || index == 0)
        {
            nregs = block->nregs+1;
            |=>index*2:
            | push rbp
            | mov rbp, rsp
            if (nregs > VM_REG_MAX)
            {
                | sub rsp, (nregs-VM_REG_MAX) * sizeof(ptrdiff_t)
            }
            for (size_t i = 0; i < block->nargs; i++)
            {
                | vmStore block->args[i], Rq(vm_ir_be_x64_arg_reg(i))
            }
        }
        |=>index*2+1:
        vm_ir_be_x64_block(Dst, &gc, &out, block);
    }
    size_t sz = 0;
    void *map = link_and_encode(Dst, &sz);
    dasm_free(Dst);
    void (*fn)(void) = labels[lbl_entry];
    fn();
    {
        FILE *out = fopen("out.dump", "wb");
        fwrite(map, 1, sz, out);
        fclose(out);
    }
#ifdef _WIN32
    VirtualFree(map, sz, MEM_RELEASE);
#else
    munmap(map, sz);
#endif
}
